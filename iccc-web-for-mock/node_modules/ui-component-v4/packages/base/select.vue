<!--
  @author: lutz
  @date: 2019-05-20
  @updateDate: 2019-06-17
  [功能描述]
    1. 弹出框滚轴事件进行改造
    2. 对el-option进行模版替换
    3. 对传入、输出的数据类型进行处理
  [备注]
      下方中没有特别标注的update。默认功能是数据源转换，请认真查看getVal
-->

<template>
  <div
    v-clickoutside="handleClose"
    :class="['el-select', selectSize ? 'el-select--' + selectSize : '']"
    @click.stop="toggleMenu"
  >
    <div
      ref="tags"
      v-if="multiple"
      class="el-select__tags"
      :style="{ 'max-width': inputWidth - 32 + 'px', width: '100%' }"
    >
      <span v-if="collapseTags && selected.length">
        <el-tag
          disable-transitions
          :closable="!selectDisabled"
          :size="collapseTagSize"
          :hit="selected[0].hitState"
          @close="deleteTag($event, selected[0])"
        >
          <span class="el-select__tags-text" :title="selected[0].currentLabel">{{ selected[0].currentLabel }}</span>
        </el-tag>
        <el-tag
          v-if="selected.length > 1"
          :closable="false"
          :size="collapseTagSize"
          disable-transitions
          :title="selectedOtherLabel"
        >
          <span class="el-select__tags-text">+ {{ selected.length - 1 }}</span>
        </el-tag>
      </span>
      <transition-group
        @after-leave="resetInputHeight"
        v-if="!collapseTags"
      >
        <el-tag
          v-for="item in selected"
          :key="getValueKey(item)"
          :closable="!selectDisabled"
          :size="collapseTagSize"
          :hit="item.hitState"
          @close="deleteTag($event, item)"
          disable-transitions
        >
          <span class="el-select__tags-text" :title="item.currentLabel">{{ item.currentLabel }}</span>
        </el-tag>
      </transition-group>

      <input
        ref="input"
        type="text"
        class="el-select__input"
        v-if="filterable"
        v-model="query"
        :class="[selectSize ? `is-${selectSize}` : '']"
        :disabled="selectDisabled"
        :autocomplete="autoComplete || autocomplete"
        :style="{
          'flex-grow': '1',
          'max-width': inputWidth - 42 + 'px',
          width: inputLength / (inputWidth - 32) + '%'
        }"
        @focus="handleFocus"
        @blur="softFocus = false"
        @click.stop
        @keyup="managePlaceholder"
        @keydown="resetInputState"
        @keydown.down.prevent="navigateOptions('next')"
        @keydown.up.prevent="navigateOptions('prev')"
        @keydown.enter.prevent="selectOption"
        @keydown.esc.stop.prevent="visible = false"
        @keydown.delete="deletePrevTag"
        @compositionstart="handleComposition"
        @compositionupdate="handleComposition"
        @compositionend="handleComposition"
        @input="debouncedQueryChange"
      />
    </div>
    <!-- update by tangdm descript: add title -->
    <el-input
      ref="reference"
      v-model="selectedLabel"
      :title="selectedLabel"
      type="text"
      :placeholder="currentPlaceholder"
      :name="name"
      :id="id"
      :autocomplete="autoComplete || autocomplete"
      :size="selectSize"
      :disabled="selectDisabled"
      :readonly="readonly"
      :validate-event="false"
      :class="{ 'is-focus': visible }"
      @focus="handleFocus"
      @blur="handleBlur"
      @keyup.native="debouncedOnInputChange"
      @keydown.native.down.stop.prevent="navigateOptions('next')"
      @keydown.native.up.stop.prevent="navigateOptions('prev')"
      @keydown.native.enter.prevent="selectOption"
      @keydown.native.esc.stop.prevent="visible = false"
      @keydown.native.tab="visible = false"
      @paste.native="debouncedOnInputChange"
      @mouseenter.native="inputHovering = true"
      @mouseleave.native="inputHovering = false"
    >
      <template
        slot="prefix"
        v-if="$slots.prefix"
      >
        <slot name="prefix"></slot>
      </template>
      <template slot="suffix">
        <i
          v-show="!showClose"
          :class="['el-select__caret', 'el-input__icon', 'el-icon-' + iconClass]"
        ></i>
        <i
          v-if="showClose"
          class="el-select__caret el-input__icon el-icon-circle-close"
          @click="handleClearClick"
        ></i>
      </template>
    </el-input>
    <transition
      name="el-zoom-in-top"
      @before-enter="handleMenuEnter"
      @after-leave="doDestroy"
    >
      <el-select-menu
        ref="popper"
        :append-to-body="popperAppendToBody"
        v-show="visible && emptyText !== false"
      >
        <template v-if="emptyText && (!allowCreate || loading || (allowCreate && options.length === 0))">
          <slot
            name="empty"
            v-if="$slots.empty"
          ></slot>
          <p
            class="el-select-dropdown__empty"
            v-else
          >{{ emptyText }}</p>
        </template>
        <!-- update-start author:lutz -->
        <dg-scrollbar
          ref="scrollbar"
          v-show="options.length > 0 && !loading"
          wrap-class="el-select-dropdown__wrap"
          view-class="el-select-dropdown__list dg-select-dropdown__list"
          :class="scrollbarCls"
          @scroll-bottom="handleScrollToBottom"
        >
          <slot></slot>
        </dg-scrollbar>
        <!-- code
          <el-scrollbar
            tag="ul"
            wrap-class="el-select-dropdown__wrap"
            view-class="el-select-dropdown__list"
            ref="scrollbar"
            :class="{ 'is-empty': !allowCreate && query && filteredOptionsCount === 0 }"
            v-show="options.length > 0 && !loading"
          >
            <el-option :value="query" created v-if="showNewOption"></el-option>
            <slot></slot>
          </el-scrollbar>
          <template
            v-if="emptyText && (!allowCreate || loading || (allowCreate && options.length === 0 ))"
          >
            <slot name="empty" v-if="$slots.empty"></slot>
            <p class="el-select-dropdown__empty" v-else>{{ emptyText }}</p>
          </template>
        -->
        <!-- update-end -->
      </el-select-menu>
    </transition>
  </div>
</template>

<script>
import { Select as ElSelect } from 'element-ui';
import DgScrollbar from 'packages/scrollbar';
import debounce from 'throttle-debounce/debounce';
import { addResizeListener } from 'main/utils/resize-event.js';
import { str2arr, data2type } from 'main/dg-utils/data-convert.js';
import { complex } from 'main/dg-utils/shear.js';
import Convert from 'main/dg-mixins/convert.js';
import { getValueByPath, valueEquals } from 'main/utils/util';
import _ from "lodash";
const Select = complex(ElSelect, ['created', 'watch', 'mounted']);

export default {
    name: 'LSelect',

    componentName: 'LSelect',

    mixins: [Select, Convert],

    components: {
        DgScrollbar
    },

    props: {
        // 给下拉框追加class
        scrollbarClass: String,

        seq: {
            type: String,
            default: ','
        },

        outputFormat: {
            type: String,
            default: 'String',
            validator: function(val) {
                return ['String', 'Array'].indexOf(val) !== -1;
            }
        },

        // 下拉树组件附加的数据
        treeData: {
            type: Array,
            default() {
                return [];
            }
        },

        // 追加文本翻译的数据 [{value: value, label: label}]
        translateData: {
            type: Array,
            default() {
                return [];
            }
        }
    },

    data() {
        return {
            // 本地文本翻译的数据
            translateLocalData: this.translateData
        }
    },

    watch: {
        translateData(val) {
            this.translateLocalData = val;
        },
        
        selectDisabled() {
            this.$nextTick(() => {
                this.resetInputHeight();
            });
        },

        placeholder(val) {
            this.cachedPlaceHolder = this.currentPlaceholder = val;
        },

        value(val, oldVal) {
            if (this.multiple) {
                this.resetInputHeight();
                if ((val && val.length > 0) || (this.$refs.input && this.query !== '')) {
                    this.currentPlaceholder = '';
                } else {
                    this.currentPlaceholder = this.cachedPlaceHolder;
                }
                if (this.filterable && !this.reserveKeyword) {
                    this.query = '';
                    this.handleQueryChange(this.query);
                }
            }
            this.setSelected();
            if (this.filterable && !this.multiple) {
                this.inputLength = 20;
            }
            if (!valueEquals(val, oldVal)) {
                this.dispatch('ElFormItem', 'el.form.change', val);
            }
        },

        visible(val) {
            if (!val) {
                this.broadcast('ElSelectDropdown', 'destroyPopper');
                if (this.$refs.input) {
                    this.$refs.input.blur();
                }
                this.query = '';

                // add author: tangdm descript: 增加搜索查询
                // this.handleQueryChange(this.query);
                this.previousQuery = null;
                this.selectedLabel = '';
                this.inputLength = 20;
                this.menuVisibleOnFocus = false;
                this.resetHoverIndex();
                this.$nextTick(() => {
                    if (this.$refs.input &&
                        this.$refs.input.value === '' &&
                        this.selected.length === 0) {
                        this.currentPlaceholder = this.cachedPlaceHolder;
                    }
                });
                if (!this.multiple) {
                    if (this.selected) {
                        if (this.filterable && this.allowCreate &&
                            this.createdSelected && this.createdLabel) {
                            this.selectedLabel = this.createdLabel;
                        } else {
                            this.selectedLabel = this.selected.currentLabel;
                        }
                        if (this.filterable) this.query = this.selectedLabel;
                    }

                    if (this.filterable) {
                        this.currentPlaceholder = this.cachedPlaceHolder;
                    }
                }
            } else {
                this.broadcast('ElSelectDropdown', 'updatePopper');
                if (this.filterable) {
                    this.query = this.remote ? '' : this.selectedLabel;
                    this.handleQueryChange(this.query);
                    if (this.multiple) {
                        this.$refs.input.focus();
                    } else {
                        if (!this.remote) {
                            this.broadcast('ElOption', 'queryChange', '');
                            this.broadcast('ElOptionGroup', 'queryChange');
                        }

                        if (this.selectedLabel) {
                            this.currentPlaceholder = this.selectedLabel;
                            this.selectedLabel = '';
                        }
                    }
                }
            }
            this.$emit('visible-change', val);
        },

        options() {
            if (this.$isServer) return;
            this.$nextTick(() => {
                this.broadcast('ElSelectDropdown', 'updatePopper');
            });
            if (this.multiple) {
                this.resetInputHeight();
            }
            let inputs = this.$el.querySelectorAll('input');
            if ([].indexOf.call(inputs, document.activeElement) === -1) {
                this.setSelected();
            }
            if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
                this.checkDefaultFirstOption();
            }
        }
    },

    computed: {
        // update author:lutz
        showClose() {
            const val = this.getVal();
            let hasValue = this.multiple
                ? Array.isArray(val) && val.length > 0
                : val !== undefined && val !== null && val !== '';
            let criteria = this.clearable && !this.selectDisabled && this.inputHovering && hasValue;
            return criteria;
        },

        scrollbarCls() {
            const { allowCreate, query, filteredOptionsCount, scrollbarClass } = this;
            return [!allowCreate && query && filteredOptionsCount === 0 ? 'is-empty' : '', scrollbarClass || ''].join(
                ' '
            );
        },

        // add author: tangdm descript: 增加标题显示
        selectedOtherLabel() {
            if(this.selected.length > 1) {
                let labels = this.selected.map(p => p.currentLabel);
                let filterLabels = labels.slice(1);
                return filterLabels.join(",");
            } else {
                return "";
            }
        }
    },

    methods: {
        // 解决因树组件展开收起后引发的样式定位问题
        updatePopper(){
            setTimeout(()=>{
                this.broadcast('ElSelectDropdown', 'updatePopper');
            },300)
        },
        resetInputHeight() {
            if (this.collapseTags && !this.filterable) return;
            this.$nextTick(() => {
                if (!this.$refs.reference) return;
                let inputChildNodes = this.$refs.reference.$el.childNodes;
                let input = [].filter.call(inputChildNodes, item => item.tagName === 'INPUT')[0];
                const tags = this.$refs.tags;
                const sizeInMap = this.initialInputHeight || 40;

                // update author: tangdm descript: 不同分辨率兼容高度问题
                // [code] input.style.height = this.selected.length === 0
                //        ? sizeInMap + 'px'
                //        : Math.max(
                //        tags ? (tags.clientHeight + (tags.clientHeight > sizeInMap ? 6 : 0)) : 0,
                //        sizeInMap
                // ) + 'px';

                input.style.height = this.selected.length === 0
                    ? sizeInMap + 'px'
                    : Math.max(
                    tags ? tags.clientHeight : 0,
                    sizeInMap
                ) + 'px';
                if (this.visible && this.emptyText !== false) {
                    this.broadcast('ElSelectDropdown', 'updatePopper');
                }
            });
        },

        // create author:lutz 下拉触发
        handleScrollToBottom() {
            this.$emit('scroll-bottom');
        },

        // create author:lutz 关闭下拉框
        handleCloseDrapdown() {
            this.visible = false;
        },

        // create author:lutz 转化value数据格式
        getVal() {
            const { multiple, value, seq } = this;
            return multiple ? str2arr(value, seq, true) : data2type(value, 'String', seq);
        },

        getOption(value) {
            let option;
            let isSearchedValue = false;
            const isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
            const isNull = Object.prototype.toString.call(value).toLowerCase() === '[object null]';
            const isUndefined = Object.prototype.toString.call(value).toLowerCase() === '[object undefined]';
            for (let i = this.cachedOptions.length - 1; i >= 0; i--) {
                const cachedOption = this.cachedOptions[i];
                const isEqual = isObject
                    ? getValueByPath(cachedOption.value, this.valueKey) === getValueByPath(value, this.valueKey)
                    : cachedOption.value === value;
                if (isEqual) {
                    // add author: tangdm descript: 追加文本翻译
                    isSearchedValue = true;

                    option = cachedOption;

                    // add author: tangdm 追加翻译缓存
                    this.translateLocalData.push({
                        label: cachedOption.currentLabel,
                        value: cachedOption.value
                    });
                    break;
                }
            }

            // add author: tangdm descript: 追加文本翻译
            if (!isSearchedValue) {
                for (let i = 0, len = this.translateLocalData.length; i < len; i++) {
                    const cachedOption = this.translateLocalData[i];
                    cachedOption.currentLabel = cachedOption.label;
                    const isEqual = isObject
                        ? getValueByPath(cachedOption.value, this.valueKey) === getValueByPath(value, this.valueKey)
                        : cachedOption.value === value;
                    if (isEqual) {
                        isSearchedValue = true;
                        option = cachedOption;
                        break;
                    }
                }
            }
            if (option) return option;
            const label = (!isObject && !isNull && !isUndefined)
                ? value : '';
            let newOption = {
                value: value,
                currentLabel: label
            };
            if (this.multiple) {
                newOption.hitState = false;
            }
            return newOption;
        },

        // update author:lutz
        setSelected() {
            const val = this.getVal();

            if (!this.multiple) {
                let option = this.getOption(val);
                if (option.created) {
                    this.createdLabel = option.currentLabel;
                    this.createdSelected = true;
                } else {
                    this.createdSelected = false;
                }
                this.selectedLabel = option.currentLabel;
                this.selected = option;
                if (this.filterable) this.query = this.selectedLabel;
                return;
            }

            let result = [];
            if (Array.isArray(val)) {
                val.forEach(value => {
                    let obj = this.getOption(value);
                    result.push(obj);
                });
            }
            this.selected = result;
            this.$nextTick(() => {
                this.resetInputHeight();
            });
        },

        // update author:lutz
        // update author: tangdm descript: repair the only one data for un-delete tag
        deleteTag(event, tag) {
            const val = this.getVal();
            let index = this.selected.indexOf(tag);
            if (index > -1 && !this.selectDisabled) {
                let value = val.slice();
                value.splice(index, 1);
                if(value.length === 0) value = "";
                this.$emit('input', value);
                this.emitChange(value);
                this.$emit('remove-tag', tag.value);
            }
            event.stopPropagation();
        },

        // update author:lutz
        deletePrevTag(e) {
            if (e.target.value.length <= 0 && !this.toggleLastOptionHitState()) {
                let val = this.getVal().slice();
                val.pop();
                const { outputFormat, seq } = this;
                val = data2type(val, outputFormat, seq);
                this.$emit('input', val);
                this.emitChange(val);
            }
        }
    },

    // update author:lutz
    created() {
        this.cachedPlaceHolder = this.currentPlaceholder = this.placeholder;

        this.debouncedOnInputChange = debounce(this.debounce, () => {
            this.onInputChange();
        });

        this.debouncedQueryChange = debounce(this.debounce, e => {
            this.handleQueryChange(e.target.value);
        });

        this.$on('handleCloseDrapdown', this.handleCloseDrapdown);
        this.$on('handleOptionClick', this.handleOptionSelect);
        this.$on('setSelected', this.setSelected);
    },

    // update author:lutz
    mounted() {
        const val = this.getVal();
        if (this.multiple && Array.isArray(val) && val.length > 0) {
            this.currentPlaceholder = '';
        }
        addResizeListener(this.$el, this.handleResize);
        const reference = this.$refs.reference;
        if (reference && reference.$el) {
            const sizeMap = { medium: 36, small: 32, mini: 28 };

            // add author: tangdm descript: 增加分辨率识别
            const clientBodyWidth = document.body.clientWidth;
            const autoFixedHeight = clientBodyWidth < 1366 ? 24 : (clientBodyWidth < 1681 ? 28 : 32);

            // update author: tangdm [code] this.initialInputHeight = input.getBoundingClientRect().height || sizeMap[this.selectSize];
            this.initialInputHeight = sizeMap[this.selectSize] || autoFixedHeight;
        }
        if (this.remote && this.multiple) {
            this.resetInputHeight();
        }
        this.$nextTick(() => {
            if (reference && reference.$el) {
                this.inputWidth = reference.$el.getBoundingClientRect().width;
            }
        });
        this.setSelected();
    }
};
</script>
