<template>
    <div class="dg-tree-select" style="width:202px">
        <l-select
            ref="select"
            style="width:100%"
            v-bind="selectProp"
            v-model="selectVal"
            :tree-data="data"
            :scrollbar-class="scrollbarCls"
            @visible-change="handleSelectFilerClose"
            @remove-tag="handleRemoveTag"
            @clear="clearDeaulf"
        >
		    <template
                slot="prefix"
                v-if="$slots.prefix"
            >
                <slot name="prefix"></slot>
            </template>
            <dg-tree ref="tree" v-bind="treeBind" @check-change="handleCheckChange" @node-collapse="handleTreeCollapse" v-on="$listeners"></dg-tree>
        </l-select>
    </div>
</template>

<script>
import LOption from './option.vue';
import LSelect from 'packages/base/select.vue';
import Convert from 'main/dg-mixins/convert.js';
import DgTree from 'packages/tree';
import { pinyin } from './pinyin.js';
import objectAssign from 'main/utils/merge';
import { str2arr, data2type } from 'main/dg-utils/data-convert.js';
import getChildrenRefs from 'main/dg-utils/children.refs.js';
import _ from 'lodash';

// 继承树的方法
let TreeRefs = {};
DgTree.mixins.forEach(item => {
    if (item.name === 'ElTree') {
        TreeRefs = getChildrenRefs(DgTree.mixins[0], 'tree');
    }
});

export default {
    name: 'DgTreeDrop',

    mixins: [Convert],

    components: {
        LSelect,
        DgTree
    },

    props: {
        treeProps: Object,
        //  别名参数
        props: Object,
        // 只能选择叶子节点需要与checkStrictly配合使用
        checkLeaf: Boolean,
        // 是否开启多选
        multiple: Boolean,
        disabled: Boolean,
        data: {
            type: Array,
            required: false
        },
        scrollbarClass: String,
        clearable: Boolean,
        // 是否父子关联 checked 生效
        checkStrictly: Boolean,
        radioType: {
            type: String,
            default: ''
        },
        value: { required: true },
        // 数据分割符号
        seq: {
            type: String,
            default: ','
        },
        // 输出的数据类型
        outputFormat: {
            type: String,
            default: 'String',
            validator: function(val) {
                return ['String', 'Array'].indexOf(val) !== -1;
            }
        },
        // 过滤节点的方法
        filterNodeMethod: Function,
        // 可显示的类型
        visibleType: {
            type: String,
            default: 'all',
            validator: function(val) {
                return ['all', 'leaf', 'branch', 'all_with_indeterminate'].indexOf(val) !== -1;
            }
        },
        valueType:{
            type:String,
            default:'all',
            validaor:function(val){
                return ['all', 'leaf', 'branch', 'all_with_indeterminate'].indexOf(val) !== -1;
            }
        },
        lazyLoad: {
            type: Boolean,
            default: false
        },
        translateData: {
            type:Array,
        }
    },

    data() {
        return {
            // 数据源
            dataSource: this.data,
            // select 传值的搜索条件
            filterText: '',
            // 是否正在重新渲染中
            // 切换数组件的数据源时，会导致树重新渲染改变node的选中状态，通过这个属性进行阻断
            rerendering: false,
            // 别名属性
            alias: {
                value: 'id',
                label: 'label',
                children: 'children',
                disabled: 'disabled',
                isLeaf: 'isLeaf'
            },
            selectVal:"",
        };
    },

    watch: {
        data: {
            deep: true,
            immediate: true,
            handler(val) {
                this.dataSource = val;

                this.$nextTick(() => {
                    // 同步下拉框值方法
                    this.syncSelectBoxValue();
                });
            }
        },
        props: {
            deep: true,
            immediate: true,
            handler(val) {
                this.alias = objectAssign(this.alias, val);
            }
        },
        filterText(val) {
            this.$refs.tree.filter(val);
        },
        value:{
            immediate:true,
            handler(val){
                let result = {};
                this.$nextTick(()=>{
                    if (this.multiple && this.$refs.tree) {
                        this.$refs.tree.setCheckedKeys(val ? val.split ? val.split(this.seq) : val : [])
                        result = this.$refs.tree.getCheckedNodes();
                    } else {
                        result = this.$refs.tree.getNode(val);
                    }
                    // radio
                    if (this.radioType === 'level' || this.radioType === 'all') {
                        this.$refs.tree.setRadioKeys(val.split(this.seq));
                    }
                    const selectFilterValue = this.translateValueToTags(val,this.visibleType);
                    this.selectVal =  data2type(selectFilterValue, 'String', this.seq);

                    const filterValue = this.translateValueToTags(val,this.valueType);
                    let formatValue = data2type(filterValue, 'String', this.seq);
                    this.$emit('input', formatValue, result);
                    this.$emit('change', formatValue, result);

                })
            }
        },
    },

    computed: {
        /**
         * 选择框组件数据处理
         */
        val: {
            // 根据值，获取下拉框的展示标签
            get() {
                // 过滤数据
                return this.value;

                // const filterValue = this.translateValueToTags(this.value,this.visibleType);
                // let formatValue = data2type(filterValue, 'String', this.seq);
                // // let filterModelValue = this.translateValueToTags(this.value,this.valueType);
                // // console.log(filterModelValue);
                // // this.$emit('input', formatValue);
                // return formatValue;
            },
            set(value) {
                // 初始化
                const tree = this.$refs.tree;
                // 若为空值，则进行数据转化
                if (!value) value = [];

                // 树节点勾选
                tree.setCheckedKeys(value);
                // 树节点
                this.setTreeOrSelectData(value);
            }
        },

        /**
         * 滚动条样式
         *
         */
        scrollbarCls() {
            return 'dg-tree-select__scrollbar ' + this.scrollbarClass;
        },

        /**
         * 合并树节点的属性参数值
         *
         */
        treeBind() {
            let treeBind = objectAssign({}, this.treeProps, {
                data: this.dataSource,
                props: this.alias,
                'node-key': this.alias.value,
                'check-leaf': this.checkLeaf,
                'show-checkbox': this.radioType === '' && this.multiple,
                'radio-type': this.radioType,
                'filter-node-method': _.isFunction(this.filterNodeMethod) ? this.filterNodeMethod : this.filterNode,
                'check-strictly': this.checkStrictly,
                'highlight-current': true,
                'render-after-expand': false,
                'render-content': this.renderContent,
            });
            return treeBind;
        },

        /**
         * 合并 select Props
         *
         */
        selectProp() {
            return objectAssign({}, this.$attrs, {
                disabled: this.disabled,
                multiple: this.multiple,
                clearable: this.clearable,
                seq: this.seq,
                'output-format': this.outputFormat,
                'filter-method': this.handleSelectFiler,
                translateData:this.translateData || this.defaultTranslateData
            });
        }
    },

    mounted(){
        if(this.$slots.prefix && this.$slots.prefix.length > 0){
            let inputPaddingLeft = 0;
            if(this.$slots.prefix[0].tag=="span" && this.$slots.prefix[0].elm.textContent){
                inputPaddingLeft = this.getByteLen(this.$slots.prefix[0].elm.textContent.trim())
                this.$refs.select.$refs.reference.$refs.input.style.paddingLeft = `calc( ${inputPaddingLeft + "em"} + 12px )`
                this.$slots.prefix[0].elm.style.lineHeight = this.$slots.prefix[0].elm.parentElement.parentElement.offsetHeight + "px"
                this.$slots.prefix[0].elm.style.marginLeft = "8px"
            }
        }

    },

    methods: {
        getByteLen(val) {
            var len = 0;
            for (var i = 0; i < val.length; i++) {
                var a = val.charAt(i);
                if (a.match(/[^\x00-\xff]/ig) != null) {
                    len += 1;
                } else {
                    len += 0.5;
                }
            }
            return len;
        },
        handleTreeCollapse(){
            if(this.$refs.select) this.$refs.select.updatePopper();
        },
        /**
         * 检索值
         *
         * @param query [String] 查询文本
         */
        handleSelectFiler(query) {
            this.filterText = query;
        },

        /**
         * 设置树或选择框的事件触发
         *
         */
        setTreeOrSelectData(val) {
            // 初始化
            const { outputFormat, seq } = this;
            const tree = this.$refs.tree;

            // 值类型转化, 若是多选的话，val 的值为 []，需要值进行转化
            if (val && val.length === 0) val = '';

            // 更新缓存值
            this.filterTreeCacheVal = val;

            // 获取选中的树节点值
            const nodes = this.multiple ? tree.getCheckedNodes() : tree.getCurrentNode();

            // 触发 input or change 事件改变
            this.$emit('input', data2type(val, outputFormat, seq), nodes);
            this.$emit('change', data2type(val, outputFormat, seq), nodes);
        },

        /**
         * tree 过滤是否显示true or false
         *
         */
        filterNode(query = '', data) {
            if (!query) {
                return true;
            }

            const { label } = this.defaultProp;
            const labelValue = _.toUpper(data[label]);

            query = _.toUpper(query);

            if (labelValue.indexOf(query) !== -1) {
                return true;
            }

            let toPinyin = pinyin(labelValue, {
                heteronym: true, // 多音
                style: pinyin.STYLE_NORMAL // 无声调
            });

            if (toPinyin && toPinyin.length > 0) {
                let str = '';
                for (let key in toPinyin) {
                    str += toPinyin[key].join('');
                }
                str = _.toUpper(str);
                toPinyin = str;
            }

            return toPinyin.indexOf(query) !== -1;
        },

        /**
         * 置空 tree 选中状态
         *
         */
        handleSelectFilerClose(bool) {
            const { val } = this;
            if (bool) {
                /*
                    BUG描述
                        form reset 多触发选中，照成父组件数据的change
                    修复：
                        this.value === '' 下拉打开的时候判断，清空选中数据
                */
                if (_.isEmpty(val) || val.length < 1) {
                    this.clearDeaulf();
                }
            } else {
                this.filterText = '';
            }
            this.$emit("visible-change",bool)
        },

        /**
         * 清空检索值
         *
         */
        clearDeaulf() {
            const tree = this.$refs.tree;

            // 清空检索值
            this.filterText = '';

            // 清空选中数据及状态
            tree.setRadioKeys([]);
            tree.setCurrentKey(null);

            // 更新 value 值
            this.$emit('input', '');
        },

        /**
         * 查找所有的 key 值
         *
         * @param val [Boolean] true/false 是否过滤叶子节点
         * @param val [Array] data 返回节点的 key 值
         */
        allKeyValue(val, data) {
            // 初始化
            let _treeData = _.cloneDeep(data);
            let _treeAllKey = [];
            let self = this;

            // 递归获取所有的 key 值
            function getAllKeyValue(data) {
                // 初始化数据
                let _treeData = _.cloneDeep(data);

                _treeData.map(base => {
                    // 检测子节点数据是否存在
                    if (base[self.alias.children] && base[self.alias.children].length > 0) {
                        // 若存在，则进行递归，获取子节点
                        getAllKeyValue(base[self.alias.children]);
                    }

                    return base;
                });

                _treeData.forEach(item => {
                    if (val) {
                        if (item[self.alias.children] && item[self.alias.children].length > 0) {
                            _treeAllKey.push(item[self.alias.value]);
                        }
                    } else {
                        _treeAllKey.push(item[self.alias.value]);
                    }
                });
            }

            // 执行方法
            getAllKeyValue(_treeData);

            return _treeAllKey;
        },

        allKeyNodes(data) {
            // 初始化
            let _treeData = _.cloneDeep(data);
            let _treeAllKey = [];
            let self = this;

            // 递归获取所有的 key 值
            function getAllKeyValue(data) {
                // 初始化数据
                let _treeData = _.cloneDeep(data);

                _treeData.map(base => {
                    // 检测子节点数据是否存在
                    if (base.childNodes && base.childNodes.length > 0) {
                        // 若存在，则进行递归，获取子节点
                        getAllKeyValue(base.childNodes);
                    }

                    return base;
                });

                _treeData.forEach(item => {
                    _treeAllKey.push(item.key);
                });
            }

            // 执行方法
            getAllKeyValue(_treeData);

            return _treeAllKey;
        },

        /**
         * 转化 `value` 为标签值
         *
         */
        translateValueToTags(value,type) {
            // 若为空数据
            if (value === null) return '';

            // 验证值是否为空，是否为空数组，为全类型
            if (
                (typeof value === 'string' && !value) ||
                (typeof value === 'object' && value.length === 0) 
            ) {
                return value;
            }
            // || type === 'all'
            // 若是多选情况
            if (this.multiple && value) {
                // 初始化
                const tree = this.$refs.tree;
                const { visibleType, defaultProp } = this;
                const { value: keyId, children } = defaultProp;
                // 检测树的值
                if (!tree) return value;

                // 树选中的节点值
                let checkedNodeKeys = tree.getCheckedKeys();
                // 值格式转化
                let formatValue = value.split?value.split(','):value;

                // 通过 value 值做检索过滤值
                switch (type) {
                    // 叶子节点
                    case 'leaf': {
                        // 树选中的叶子节点值
                        const checkedLeafKeys = tree.getCheckedKeys(true);
                        if(checkedLeafKeys && checkedLeafKeys.length){
                            return checkedLeafKeys;
                        }
                        return formatValue;
                        // 比较之间的差值
                        // const diff = _.difference(checkedNodeKeys, checkedLeafKeys);
                        // return _.difference(formatValue, diff);
                    }
                    // 枝干节点
                    case 'branch': {
                        // 检测是否懒加载
                        if (this.treeBind.lazy && this.multiple) {
                            const allNodes = tree.getCheckedNodes(false, false); //todo
                            let treeNodes = tree.store.root.childNodes;

                            const diffNodes = nodes => {
                                let child = [];
                                const flatter = arr => {
                                    arr.forEach(item => {
                                        if (item.checked) {
                                            child.push(item);
                                        } else {
                                            child.push(item);
                                            if (item.childNodes && item.childNodes.length) {
                                                flatter(item.childNodes);
                                            }
                                        }
                                    });
                                };

                                // 枝干节点过滤
                                flatter(nodes);
                                return child;
                            };
                            let branchOrLeafNodeKeys = diffNodes(treeNodes).map(item => item.key);
                            let branchNodeKeys = [];
                            branchOrLeafNodeKeys.map(item=>{
                                if(checkedNodeKeys.indexOf(item)>-1){
                                    branchNodeKeys.push(item);
                                }
                            });
                            if(branchNodeKeys.length){
                                return branchNodeKeys;
                            }
                            return formatValue;
                            // let branchOtherDiff = _.difference(checkedNodeKeys, branchOrLeafNodeKeys);
                            // let otherDiff = branchOtherDiff.length? branchOtherDiff.join(",").split(",") : branchOtherDiff;
                            // return _.uniq([...formatValue, ...otherDiff]);
                            // return _.difference(formatValue, branchOtherDiff);
                        } else {
                            
                            const allNodes = tree.getCheckedNodes(false, false);
                            const diffNodes = allNodes => {
                                let child = [];
                                let del = []; // 剔除的id
                                // 去掉重复的选中项
                                const flatter = arr => {
                                    arr.forEach(item => {
                                        const index = _.findIndex(child, { [keyId]: item[keyId] });
                                        if (index > -1) {
                                            del = del.concat(child.splice(index, 1));
                                        } else {
                                            const delIndex = _.findIndex(del, { [keyId]: item[keyId] });
                                            if (delIndex === -1) {
                                                child.push(item);
                                            }
                                        }
                                        if (item[children] && item[children].length) {
                                            flatter(item[children]);
                                        }
                                    });
                                };
                                flatter(allNodes);
                                return child;
                            };
                            let branchOrLeafNodeKeys = diffNodes(allNodes).map(item => item[keyId]);
                            // 不是通过value设置（手动勾选）
                            if (_.intersection(checkedNodeKeys, formatValue).length == formatValue.length) {
                                return branchOrLeafNodeKeys;
                            }
                            let branchOtherDiff = _.difference(checkedNodeKeys, branchOrLeafNodeKeys);
                            return _.difference(formatValue, branchOtherDiff);
                        }
                    }
                    case 'all':{
                        const checkedLeafKeys = tree.getCheckedKeys(false);
                        if(checkedLeafKeys && checkedLeafKeys.length){
                            return checkedLeafKeys;
                        }
                        return formatValue;
                    }
                    default: {
                        return formatValue;
                    }
                }
            }

            return value;
        },

        handleCheckChange(data, checked, indeterminate) {
            // 切换数组件的数据源时，会导致树重新渲染改变node的选中状态，通过这个属性进行阻断
            // huangjq 20201201
            if (this.rerendering && !checked) {
                return;
            }

            let value = data2type(this.value, 'String', this.seq);

            // 若存在缓存值，则原先不归属于树节点（懒加载情况下），则进行追加文本显示
            if (this.treeBind.lazy && this.multiple) {
                // 正则表达式，是否存在 "," 分割
                let reg = /^.*[\,,].*$/;
                // 缓存字段数据
                let cacheArray = [];

                if (value) {
                    // 缓存字段是否为多个数据
                    if (reg.test(value)) {
                        cacheArray = value.split(',');
                    } else {
                        cacheArray.push(value);
                    }
                }

                // 选中字段
                if (checked) {
                    let selectedTreeKeys = this.$refs.tree.getCheckedKeys(false);
                    let coopArray = _.concat(selectedTreeKeys, cacheArray);
                    cacheArray = _.uniq(coopArray);
                } else {
                    let nodes = this.$refs.tree.getNode(data);
                    let selectedTreeKeys = this.$refs.tree.getCheckedKeys(false);
                    let filterArray = this.allKeyNodes(nodes.childNodes);
                    filterArray.push(nodes.key);
                    cacheArray = _.concat(cacheArray, selectedTreeKeys);
                    cacheArray = _.uniq(cacheArray);
                    filterArray = _.difference(filterArray, selectedTreeKeys);
                    cacheArray = _.difference(cacheArray, filterArray);
                    cacheArray = cacheArray ? cacheArray : [];
                }

                this.$emit('input', data2type(cacheArray, 'String', this.seq));

                this.$emit('check-change', data, checked, indeterminate);
            } else {
                var _seq = this.seq,
                    outputFormat = this.outputFormat;

                var _data = this.$refs.tree.getCheckedKeys(false);
                this.$emit('input', data2type(_data, outputFormat, _seq));

                this.$emit('check-change', data, checked, indeterminate);
            }
        },

        // 渲染 option 到 tree
        renderContent(h, { node, data, store }) {
            const { label, value, disabled } = this.defaultProp;

            return h(LOption, {
                props: {
                    key: data[value],
                    label: data[label],
                    value: data[value],
                    disabled: data[disabled],
                    isHighLight: node.store.isHighLight,
                    filter: node.filter
                }
            });
        },

        // 同步下拉框值方法
        syncSelectBoxValue() {
            const { seq } = this;
            const value = data2type(this.value, 'String', seq);
            const { radioType, showCheckbox, itemsWithDisabled, nodeKey, checkStrictly } = this.$refs.tree;
            const valArr = str2arr(value, seq, true, itemsWithDisabled, nodeKey);

            // radio
            if (radioType === 'level' || radioType === 'all') {
                this.$refs.tree.setRadioKeys(valArr);
            }

            // checkbox
            if (showCheckbox) {
                const preCheckedArr = this.$refs.tree.getCheckedKeys();
                const oldValArr = str2arr(preCheckedArr, seq);

                if (valArr.length && oldValArr.length && !checkStrictly) {
                    const diffArr = _.difference(oldValArr, valArr);

                    // 剔除父及祖先级元素
                    const traverseParent = function(node, valArr) {
                        const parentNode = node.parent;
                        if (parentNode && parentNode.level != 0) {
                            _.remove(valArr, n => parentNode.data[nodeKey] === n);
                            traverseParent(parentNode, valArr);
                        }
                    };

                    // 剔除所有子代及子孙元素
                    const traverseChild = function(node, valArr) {
                        const childNodes = node.childNodes;
                        if (childNodes && childNodes.length) {
                            childNodes.forEach(item => {
                                _.remove(valArr, n => n === item.data[nodeKey]);
                            });
                            traverseChild(childNodes, valArr);
                        }
                    };

                    diffArr.forEach(item => {
                        const node = this.$refs.tree.getNode(item);
                        if (node) {
                            traverseParent(node, valArr);
                            traverseChild(node, valArr);
                        }
                    });
                }
                this.$refs.tree.setCheckedKeys(valArr);
            }

            // highlight
            if (!showCheckbox && radioType === '' && valArr.length < 2) {
                this.$refs.tree.setCurrentKey(valArr);
            }
        },
        // 删除标签
        handleRemoveTag(val) {
            this.$refs.tree.setChecked(val, false, true);
        },
        ...TreeRefs
    }
};
</script>
