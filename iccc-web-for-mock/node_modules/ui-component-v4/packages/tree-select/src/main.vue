<template>
  <div class="dg-tree-select">
    <l-select
      v-bind="selectProp"
      v-model="val"
      :tree-data="data"
      :scrollbar-class="scrollbarCls"
      @visible-change="handleSelectFilerClose"
      @clear="clearDeaulf"
    >
      <dg-tree
        ref="tree"
        v-model="checkedTree"
        v-bind="treeBind"
        @check-change="handleCheckChange"
        v-on="$listeners"
      ></dg-tree>
    </l-select>
  </div>
</template>

<script>
import LOption from './option.vue';
import LSelect from 'packages/base/select.vue';
import Convert from 'main/dg-mixins/convert.js';
import DgTree from 'packages/tree';
import { pinyin } from './pinyin.js';
import objectAssign from 'main/utils/merge';
import { data2type } from 'main/dg-utils/data-convert.js';
import getChildrenRefs from 'main/dg-utils/children.refs.js';
import _ from 'lodash';

// 继承树的方法
let TreeRefs = {};
DgTree.mixins.forEach(item => {
    if (item.name === 'ElTree') {
        TreeRefs = getChildrenRefs(DgTree.mixins[0], 'tree');
    }
});

export default {
    name: 'DgTreeSelect',

    mixins: [Convert],

    components: {
        LSelect,
        DgTree
    },

    props: {
        treeProps: Object,
        //  别名参数
        props: Object,
        // 只能选择叶子节点需要与checkStrictly配合使用
        checkLeaf: Boolean,
        // 是否开启多选
        multiple: Boolean,
        disabled: Boolean,
        data: {
            type: Array,
            required: false
        },
        scrollbarClass: String,
        clearable: Boolean,
        // 是否父子关联 checked 生效
        checkStrictly: Boolean,
        radioType: {
            type: String,
            default: ''
        },
        value: { required: true },
        // 数据分割符号
        seq: {
            type: String,
            default: ','
        },
        // 输出的数据类型
        outputFormat: {
            type: String,
            default: 'String',
            validator: function(val) {
                return ['String', 'Array'].indexOf(val) !== -1;
            }
        },
        // 过滤节点的方法
        filterNodeMethod: Function,
        // 可显示的类型
        visibleType: {
            type: String,
            default: 'all',
            validator: function(val) {
                return ['all', 'leaf', 'branch', 'all_with_indeterminate'].indexOf(val) !== -1;
            }
        }
    },

    data() {
        return {
            // 数据源
            dataSource: this.data,
            // select 传值的搜索条件
            filterText: '',
            // 树会导致 v-model value 值变化两次，增加缓存控制
            filterTreeCacheVal: this.value,
            // 别名属性
            alias: {
                value: 'id',
                label: 'label',
                children: 'children',
                disabled: 'disabled',
                isLeaf: 'isLeaf'
            }
        };
    },

    watch: {
        data: {
            deep: true,
            immediate: true,
            handler(val) {
                this.dataSource = val;
            }
        },
        props: {
            deep: true,
            immediate: true,
            handler(val) {
                this.alias = objectAssign(this.alias, val);
            }
        },
        filterText(val) {
            this.$refs.tree.filter(val);
        }
    },

    computed: {
        /**
         * 选择框组件数据处理
         */
        val: {
            get() {
                const { value, seq } = this;

                // 过滤数据
                const filterValue = this.filterNodeKey(value);

                return data2type(filterValue, 'String', seq);
            },
            set(val) {
                const tree = this.$refs.tree;

                if (!val) val = [];

                if (this.visibleType === 'branch') {
                    if (val.length === 0) tree.setCheckedKeys(val);

                    val.forEach(item => {
                        let nodes = tree.getNode(item);
                        let keys = this.allKeyNodes(nodes.childNodes);
                        val = _.concat(val, keys);
                    });

                    tree.setCheckedKeys(val);
                } else {
                    // 对数据进行过滤
                    tree.setCheckedKeys(val);
                }
                this.setTreeOrSelectData(val);
            }
        },
        /**
         * 树组件数据处理
         *
         */
        checkedTree: {
            get() {
                const { value, seq } = this;

                return data2type(value, 'String', seq);
            },
            set(val) {
                // change 事件触发
                this.setTreeOrSelectData(val);
            }
        },

        /**
         * 滚动条样式
         *
         */
        scrollbarCls() {
            return 'dg-tree-select__scrollbar ' + this.scrollbarClass;
        },

        /**
         * 合并 tree Props
         *
         */
        treeBind() {
            return objectAssign({}, this.treeProps, {
                data: this.dataSource,
                props: this.alias,
                'node-key': this.alias.value,
                'check-leaf': this.checkLeaf,
                'show-checkbox': this.radioType === '' && this.multiple,
                'radio-type': this.radioType,
                'filter-node-method': _.isFunction(this.filterNodeMethod) ? this.filterNodeMethod : this.filterNode,
                'check-strictly': this.checkStrictly,
                'highlight-current': true,
                'render-after-expand': false,
                'render-content': this.renderContent
            });
        },

        /**
         * 合并 select Props
         *
         */
        selectProp() {
            return objectAssign({}, this.$attrs, {
                disabled: this.disabled,
                multiple: this.multiple,
                clearable: this.clearable,
                seq: this.seq,
                'output-format': this.outputFormat,
                'filter-method': this.handleSelectFiler
            });
        }
    },

    created(){
        console && console.warn && console.warn("dg-tree-select组件在接下来的版本将要移除，请使用dg-tree-drop")
    },

    methods: {
        /**
         * 检索值
         *
         * @param query [String] 查询文本
         */
        handleSelectFiler(query) {
            this.filterText = query;
        },

        /**
         * 设置树或选择框的事件触发
         *
         */
        setTreeOrSelectData(val) {
            const { outputFormat, seq } = this;

            // 值类型转化, 若是多选的话，val 的值为 []，需要值进行转化
            if (val && val.length === 0) val = '';

            // 过滤树会触发 父级选择框半选或全选状态
            if (val !== this.filterTreeCacheVal) {
                // 更新缓存值
                this.filterTreeCacheVal = val;

                // 获取选中的树节点值
                const tree = this.$refs.tree;
                const nodes = this.multiple ? tree.getCheckedNodes() : tree.getCurrentNode();

                // 触发 input or change 事件改变
                this.$emit('input', data2type(val, outputFormat, seq), nodes);
                this.$emit('change', data2type(val, outputFormat, seq), nodes);
            }
        },

        // tree 过滤是否显示true or false
        filterNode(query = '', data) {
            if (!query) {
                return true;
            }

            const { label } = this.defaultProp;
            const labelValue = _.toUpper(data[label]);

            query = _.toUpper(query);

            if (labelValue.indexOf(query) !== -1) {
                return true;
            }

            let toPinyin = pinyin(labelValue, {
                heteronym: true, // 多音
                style: pinyin.STYLE_NORMAL // 无声调
            });

            if (toPinyin && toPinyin.length > 0) {
                let str = '';
                for (let key in toPinyin) {
                    str += toPinyin[key].join('');
                }
                str = _.toUpper(str);
                toPinyin = str;
            }

            return toPinyin.indexOf(query) !== -1;
        },

        /**
         * 置空 tree 选中状态
         *
         */
        handleSelectFilerClose(bool) {
            const { val } = this;
            if (bool) {
                /*
                    BUG描述
                        form reset 多触发选中，照成父组件数据的change
                    修复：
                        this.value === '' 下拉打开的时候判断，清空选中数据
                */
                if (_.isEmpty(val) || val.length < 1) {
                    this.clearDeaulf();
                }
            } else {
                this.filterText = '';
            }
        },

        /**
         * 清空检索值
         *
         */
        clearDeaulf() {
            const tree = this.$refs.tree;

            // 清空检索值
            this.filterText = '';

            // 清空选中数据及状态
            tree.setRadioKeys([]);
            tree.setCurrentKey(null);
            this.$emit("input", "");
        },

        /**
         * 过滤类型数据
         *
         * @param value 文本数据值
         * @return value 过滤后的文本数据值
         */
        filterNodeKey(value) {
            // 若为空数据
            if(value === null) return "";

            // 验证值是否为空，是否为空数组，为全类型
            if (
                (typeof value === 'string' && !value) ||
                (typeof value === 'object' && value.length === 0) ||
                this.visibleType === 'all'
            ) {
                return value;
            }

            // 若是多选情况，过滤
            if (this.multiple) {
                const tree = this.$refs.tree;
                if (!tree) {
                    return value;
                }

                const { visibleType, defaultProp } = this;
                const { value: keyId, children } = defaultProp;

                // 获取选中节点
                const getCheckNodes = (leafOnly, includeHalfChecked, needId = true) => {
                    const check = tree.getCheckedNodes(leafOnly, includeHalfChecked);
                    return needId ? check.map(item => item[keyId]) : check;
                };

                switch (visibleType) {
                    case 'leaf': {
                        return getCheckNodes(true, false);
                    }
                    case 'branch': {
                        const allNodes = getCheckNodes(false, false, false);
                        const diffNodes = (allNodes) => {
                            let child = [];
                            let del = []; // 剔除的id
                            // 去掉重复的选中项
                            const flatter = arr => {
                                arr.forEach(item => {
                                    const index = _.findIndex(child, { [keyId]: item[keyId] });
                                    if (index > -1) {
                                        del = del.concat(child.splice(index, 1));
                                    } else {
                                        const delIndex = _.findIndex(del, { [keyId]: item[keyId] });
                                        if (delIndex === -1) {
                                            child.push(item);
                                        }
                                    }
                                    if (item[children] && item[children].length) {
                                        flatter(item[children]);
                                    }
                                });
                            };
                            flatter(allNodes);
                            return child;
                        };
                        return diffNodes(allNodes).map(item => item[keyId]);
                    }
                    case 'all_with_indeterminate': {
                        return getCheckNodes(false, true);
                    }
                }
            }

            return value;
        },

        /**
         * 查找所有的 key 值
         *
         * @param val [Boolean] true/false 是否过滤叶子节点
         * @param val [Array] data 返回节点的 key 值
         */
        allKeyValue(val, data) {
            // 初始化
            let _treeData = _.cloneDeep(data);
            let _treeAllKey = [];
            let self = this;

            // 递归获取所有的 key 值
            function getAllKeyValue(data) {
                // 初始化数据
                let _treeData = _.cloneDeep(data);

                _treeData.map(base => {
                    // 检测子节点数据是否存在
                    if (base[self.alias.children] && base[self.alias.children].length > 0) {
                        // 若存在，则进行递归，获取子节点
                        getAllKeyValue(base[self.alias.children]);
                    }

                    return base;
                });

                _treeData.forEach(item => {
                    if (val) {
                        if (item[self.alias.children] && item[self.alias.children].length > 0) {
                            _treeAllKey.push(item[self.alias.value]);
                        }
                    } else {
                        _treeAllKey.push(item[self.alias.value]);
                    }
                });
            }

            // 执行方法
            getAllKeyValue(_treeData);

            return _treeAllKey;
        },

        allKeyNodes(data) {
            // 初始化
            let _treeData = _.cloneDeep(data);
            let _treeAllKey = [];
            let self = this;

            // 递归获取所有的 key 值
            function getAllKeyValue(data) {
                // 初始化数据
                let _treeData = _.cloneDeep(data);

                _treeData.map(base => {
                    // 检测子节点数据是否存在
                    if (base.childNodes && base.childNodes.length > 0) {
                        // 若存在，则进行递归，获取子节点
                        getAllKeyValue(base.childNodes);
                    }

                    return base;
                });

                _treeData.forEach(item => {
                    _treeAllKey.push(item.key);
                });
            }

            // 执行方法
            getAllKeyValue(_treeData);

            return _treeAllKey;
        },

        handleCheckChange(data, checked, indeterminate) {
            let value = data2type(this.value, 'String', this.seq);

            // 若存在缓存值，则原先不归属于树节点（懒加载情况下），则进行追加文本显示
            if(this.treeBind.lazy && this.multiple) {

                // 正则表达式，是否存在 "," 分割
                let reg = /^.*[\,,].*$/;
                // 缓存字段数据
                let cacheArray = [];

                if(value) {
                    // 缓存字段是否为多个数据
                    if (reg.test(value)) {
                        cacheArray = value.split(",");
                    } else {
                        cacheArray.push(value)
                    }
                }

                // 选中字段
                if (checked) {
                    let selectedTreeKeys = this.$refs.tree.getCheckedKeys(false);
                    let coopArray = _.concat(selectedTreeKeys, cacheArray);
                    cacheArray = _.uniq(coopArray);
                } else {
                    let nodes = this.$refs.tree.getNode(data);
                    let selectedTreeKeys = this.$refs.tree.getCheckedKeys(false);
                    let filterArray = this.allKeyNodes(nodes.childNodes);
                    filterArray.push(nodes.key);
                    cacheArray = _.concat(cacheArray, selectedTreeKeys);
                    cacheArray = _.uniq(cacheArray);
                    filterArray = _.difference(filterArray, selectedTreeKeys);
                    cacheArray = _.difference(cacheArray, filterArray);
                    cacheArray = cacheArray ? cacheArray : [];
                }

                this.$emit("input", data2type(cacheArray, 'String', this.seq));

                this.$emit("check-change", data, checked, indeterminate);

            } else {
                var _seq = this.seq,
                    outputFormat = this.outputFormat;

                var _data = this.$refs.tree.getCheckedKeys(false);
                this.$emit('input', data2type(_data, outputFormat, _seq));

                this.$emit("check-change", data, checked, indeterminate);
            }
        },

        // 渲染 option 到 tree
        renderContent(h, { node, data, store }) {
            const { label, value, disabled } = this.defaultProp;

            return h(LOption, {
                props: {
                    key: data[value],
                    label: data[label],
                    value: data[value],
                    disabled: data[disabled]
                }
            });
        },
        ...TreeRefs
    }
};
</script>
