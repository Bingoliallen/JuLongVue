<template>
    <div class="dg-log-search">
        <!-- 内容滚动 -->
        <div class="dg-log-search__content" @mouseenter="handleEnterHover" @mouseleave="handleRemoveHover">
            <dg-scrollbar
                ref="scrollbar"
                :busy-loading="busyLoading"
                load-distance
                @scroll-top="scrollTop"
                @scroll-event="scrollEvent"
                @scroll-bottom="scrollBottom"
            >
                <ul class="dg-log-search__list" ref="searchWrap">
                    <li class="dg-log-search__item" v-for="(item, index) in dataSource" :key="index">
                        <slot :data="item"></slot>
                    </li>
                </ul>
            </dg-scrollbar>
        </div>
    </div>
</template>

<script>
import _ from 'lodash';
import $ from 'jquery';

export default {
    name: 'DgLogSearch',
    props: {
        // 目标数据
        data: {
            type: Array,
            default: []
        },
        // 是否自动滚动
        isAutoScroll: {
            type: Boolean,
            default: false
        },
        // 滚动置顶触发
        scrollTop: {
            type: Function,
            default: () => {}
        },
        // 滚动置底触发
        scrollBottom: {
            type: Function,
            default: () => {}
        },
        // 滚动触发
        scrollEvent: {
            type: Function,
            default: () => {}
        },
        // 限制条数
        limitCounts: {
            type: Number,
            default: 0
        },
        // 禁止触发上下加载数据
        isDisableLoadData: {
            type: Boolean,
            default: false
        }
    },
    data() {
        return {
            // 数据源
            dataSource: this.data,
            // 加载锁定(阻止置顶触发事件及置底触发事件)
            busyLoading: true,
            // 缓存推送的数据
            cacheData: [],
            // 过滤的字段
            filterValue: '',
            // 过滤的位置存储
            filterArray: []
        };
    },
    watch: {
        /**
         * 监听目标数据的改变
         *
         * @param val
         */
        data(val) {
            this.dataSource = val;
        },
        /**
         * 监听 isDisableLoadData 改变
         *
         */
        isDisableLoadData(val) {
            this.busyLoading = !val;
        }
    },
    methods: {
        // 置顶方法
        goScrollToTop() {
            this.$refs.scrollbar.goScrollToTop();
        },
        // 置底方法
        goScrollToBottom() {
            this.$refs.scrollbar.goScrollToBottom();
        },
        // 滚动到指定的位置
        goScrollToPositionY(y, animateTime, callback) {
            this.$refs.scrollbar.goScrollToYAxis(y, animateTime, callback);
        },
        // 清空数据
        clearData() {
            this.dataSource = [];
        },
        /**
         * 数据更新加载入新的条数方法
         *
         * @param data [Array] 数据
         * @param type [String] 字符串
         */
        loadingData(data, type) {
            let self = this;

            let itemHeight = this.$refs.searchWrap.children.length > 0 ? this.$refs.searchWrap.children[0].clientHeight : 0;

            // 检测是否限制最大条数
            if (this.limitCounts) {
                // 计算超出条数
                let deleteCounts =
                    this.limitCounts > this.dataSource.length + data.length
                        ? 0
                        : data.length + this.dataSource.length - this.limitCounts;

                // 检测是否超出
                if (!isNaN(this.limitCounts) && deleteCounts > 0 && type === 'down' && this.busyLoading) {
                    // 删除指定条数
                    self.dataSource.splice(0, deleteCounts);

                    // 重置滚动条位置
                    const scrollTop = this.$refs.scrollbar.wrap.scrollTop;
                    this.$refs.scrollbar.wrap.scrollTop = scrollTop - data.length * itemHeight;
                }
            }

            // 数据操作
            if (type === 'up') {
                data.forEach(item => {
                    this.dataSource.unshift(item);
                });
            } else if (type === 'down') {
                data.forEach(item => {
                    this.dataSource.push(item);
                });
            }
        },
        /**
         * 数据实时推送的方法
         *
         * @param data [Array] 数据
         */
        realTimeLoading(data) {
            let itemHeight = this.$refs.searchWrap.children.length > 0 ? this.$refs.searchWrap.children[0].clientHeight : 0;

            // 检测是否限制最大条数
            if (this.limitCounts) {
                // 检测当前的数据加载的状态，若属于加载锁定状态
                if (this.busyLoading) {
                    // 是否存在缓存数据
                    if (this.cacheData.length > 0) {
                        // 合并内容数据
                        this.dataSource = _.concat(this.dataSource, this.cacheData, data);

                        // 更新数据内容
                        this.dataSource.splice(0, this.dataSource.length - this.limitCounts);

                        // 清空缓存数据
                        this.cacheData = [];
                    } else {
                        this.loadingData(data, 'down');
                    }

                    // 是否自动滚动
                    if (this.isAutoScroll) {
                        const scrollTop =
                            this.$refs.scrollbar.wrap.scrollHeight - this.$refs.scrollbar.wrap.clientHeight;
                        this.$refs.scrollbar.wrap.scrollTop = scrollTop;
                    }
                } else {
                    // 是否存在缓存数据
                    if (this.limitCounts <= this.dataSource.length) {
                        this.cacheData = this.cacheData.concat(data);
                    } else {
                        // 计算数据拆分的条数
                        let deleteCounts = this.dataSource.length + data.length - this.limitCounts;

                        // 检测是否超出
                        if (deleteCounts > 0) {
                            // 删除特定条数
                            this.dataSource.splice(0, deleteCounts);

                            // 追加指定条数
                            let addData = data.slice(0, deleteCounts);
                            this.dataSource = this.dataSource.concat(addData);

                            // 缓存条数增加
                            let newData = data.slice(deleteCounts);
                            this.cacheData = this.cacheData.concat(newData);

                            // 重置滚动条位置
                            const scrollTop = this.$refs.scrollbar.wrap.scrollTop;
                            this.$refs.scrollbar.wrap.scrollTop = scrollTop - newData.length * itemHeight;
                        } else {
                            this.dataSource = this.dataSource.concat(data);
                        }
                    }
                }
            } else {
                // 无限制则直接追加数据
                data.forEach(item => {
                    this.dataSource.push(item);
                });

                // 是否自动滚动
                if (this.isAutoScroll && this.busyLoading) {
                    const scrollTop = this.$refs.scrollbar.wrap.scrollHeight - this.$refs.scrollbar.wrap.clientHeight;
                    this.$refs.scrollbar.wrap.scrollTop = scrollTop;
                }
            }
        },
        /**
         * 鼠标上移悬浮时操作
         *
         */
        handleEnterHover() {
            // 取消滚动锁定加载
            this.busyLoading = this.isDisableLoadData;

            // 触发进入操作
            this.$emit('hover-enter');
        },
        /**
         * 鼠标移除悬浮时操作
         *
         */
        handleRemoveHover() {
            // 滚动锁定加载
            this.busyLoading = true;

            // 触发离开操作
            this.$emit('hover-leave');
        },
        /**
         * 查询数据高亮方法
         *
         * @param item [String] 查询对应文本
         * @param filterKey [String] 过滤文本
         */
        searchHighLightMethods(item, filterKey) {
            // 界面中查找特定值
            if (!filterKey) return item;

            const result = item.replace(
                new RegExp(filterKey + '{1}'),
                `<span class="dg-log-search__light">${filterKey}</span>`
            );
            return result;
        },
        /**
         * 滚动到匹配指定的位置
         *
         */
        scrollToPointPosition(filterValue) {
            // 去除两端的空格
            filterValue = $.trim(filterValue);

            // 校验不为空值
            if (!filterValue) return false;

            // 比较与原先的值是否有变化
            if (this.filterValue === filterValue) {
                let scrollTop = this.$refs.scrollbar.wrap.scrollTop;
                let scrollHeight = this.$refs.scrollbar.wrap.scrollHeight;
                let clientHeight = this.$refs.scrollbar.wrap.clientHeight;
                let flag = true;

                // 滚动位置判断
                for (let i = 0, len = this.filterArray.length; i < len; i++) {
                    // 滚动置底，则无需遍历后续的值
                    if (scrollTop + clientHeight === scrollHeight) break;

                    // 滚动至下一个值
                    if (this.filterArray[i] > scrollTop) {
                        flag = false;
                        this.goScrollToPositionY(this.filterArray[i], 200);
                        break;
                    }
                }

                // 若置底，则恢复初始位置
                if (flag) this.goScrollToPositionY(this.filterArray[0], 200);
            } else {
                let $filterSpan = $(this.$el).find('.dg-log-search__light');
                this.filterArray = [];
                this.filterValue = filterValue;
                let self = this;

                $.each($filterSpan, function(index, item) {
                    let _value = item.closest('li').offsetTop;
                    self.filterArray.push(_value);
                });

                this.goScrollToPositionY(this.filterArray[0], 200);
            }
        }
    },
    mounted() {
        // DOM 加载完成
        this.$nextTick(() => {
            // 是否启用自动滚动
            if (this.isAutoScroll) {
                const scrollHeight = this.$refs.scrollbar.wrap.scrollHeight;
                this.$refs.scrollbar.goScrollToYAxis(scrollHeight);
            }
        });
    }
};
</script>
