<template>
    <div class="dg-group-select">
        <l-select
            v-bind="selectProp"
            v-model="val"
            ref="select"
            popper-class="group-select-popper"
            :scrollbar-class="scrollbarCls"
            :translate-data="translateData"
            @visible-change="handleSelectFilerClose"
            @remove-tag="handleRemoveTag"
            @clear="clearDeaulf"
        >
            <template >
                <div v-show="isEditing">
                    <div class="group-setting" >
                        <div class="header">
                            <span class="title-wrap">分组管理</span>
                            <span class="desc-wrap">注：可拖拽进行分组排序</span>
                            <span class="button-wrap">
                                <el-button type="text" @click="isEditing = false">返回</el-button>
                            </span>
                        </div>
                        <div class="content">
                            <el-form>
                                <el-form-item label="" style="margin-bottom: 0;">
                                    <transfer-tree
                                        ref="editTree"
                                        :data="data"
                                        :group-data="innerGroupData"
                                        :titles="['全部','分组']"
                                        :label-name="alias.label"
                                        :value-name="alias.value"
                                        :filterable="transferFilterable"
                                        :clearable="transferClearable"
                                        :all-tree-props="treeBind"
                                        v-bind="groupTreeBind"
                                        @group-tree-change="handleGroupTreeChange"
                                        @delete-group="handleDeleteGroup"
                                        @save-group="handleSaveGroup"
                                        @after-drag="handleAfterGrag"
                                    ></transfer-tree>
                                </el-form-item>
                            </el-form>
                        </div>
                    </div>
                </div>
                <div v-show="!isEditing">
                    <el-tabs type="border-card" v-model="tabKey" class="dg-group-select_el-tab">
                        <el-tab-pane
                            v-for="item in getShowTabs()"
                            :key="item.tabKey"
                            :label="item.label"
                            :name="item.ref"
                            style="height:280px;width: calc( 100% + 14px);"
                        >
                            <dg-scrollbar view-style="padding-right:14px;">
                                <template v-if="item.tabKey=='group'">
                                    <!-- 分组树 -->
                                    <dg-tree
                                        :ref="item.ref"
                                        :data="item.data"
                                        :class="{'hide-parent-checkbox': !checkGroup}"
                                        v-on="$listeners"
                                        v-bind="groupTreeBind"
                                        :render-content="item.renderContent"
                                        @check-change="item.checkChange"
                                        @node-click="handleNodeClick"
                                    ></dg-tree>
                                </template>
                                <template v-else-if="item.renderContent">
                                    <!-- 常用树 -->
                                    <dg-tree
                                        :ref="item.ref"
                                        :data="item.data"
                                        v-bind="mostTreeBind"
                                        v-on="$listeners"
                                        :render-content="item.renderContent"
                                        @check-change="item.checkChange"
                                        @node-click="handleNodeClick"
                                    ></dg-tree>
                                </template>
                                <template v-else>
                                    <!-- 全部树 -->
                                    <dg-tree
                                        :ref="item.ref"
                                        :data="item.data"
                                        v-bind="treeBind"
                                        v-on="$listeners"
                                        @check-change="item.checkChange"
                                        @node-click="handleNodeClick"
                                    ></dg-tree>
                                </template>
                            </dg-scrollbar>
                        </el-tab-pane>
                    </el-tabs>
                    <div class="group-manager">
                        <el-button
                            type="text"
                            v-if="useGroup && allowEditGroup"
                            @click="isEditing=true"
                        >分组管理</el-button>
                    </div>
                </div>
            </template>
        </l-select>
    </div>
</template>

<script>
import LOption from './option.vue';
import LSelect from 'packages/base/select.vue';
import Convert from 'main/dg-mixins/convert.js';
import DgTree from 'packages/tree';
import { pinyin } from './pinyin.js';
import objectAssign from 'main/utils/merge';
import { str2arr, data2type } from 'main/dg-utils/data-convert.js';
import getChildrenRefs from 'main/dg-utils/children.refs.js';
import _ from 'lodash';
import TransferTree from './transfer-tree';

// 继承树的方法
let TreeRefs = {};
DgTree.mixins.forEach(item => {
    if (item.name === 'ElTree') {
        TreeRefs = getChildrenRefs(DgTree.mixins[0], 'tree');
    }
});

export default {
    name: 'DgGroupSelect',

    mixins: [Convert],

    components: {
        LSelect,
        DgTree,
        TransferTree
    },

    props: {
        // 树属性
        treeProps: {
            type: Object,
            default: () => ({})
        },
        // 常用树属性
        mostTreeProps: Object,
        // 分组树属性
        groupTreeProps: Object,
        // 别名参数
        props: Object,
        // 只能选择叶子节点需要与checkStrictly配合使用
        checkLeaf: Boolean,
        // 是否开启多选
        multiple: Boolean,
        // 是否禁用
        disabled: Boolean,
        // 是否开启分组
        useGroup: {
            type: Boolean,
            default: true
        },
        // 开启分组编辑按钮
        allowEditGroup: {
            type: Boolean,
            default: true
        },
        // 是否开启常用
        useMost: {
            type: Boolean,
            default: true
        },
        // 菜单面板显示顺序
        tabOrder: {
            type: Array,
            default: () => ['all', 'group', 'most']
        },
        // 开启本地储存时的关键字
        chooseKey: {
            type: String,
            default: 'defaultGroupSelect'
        },
        // 本地储存数据
        isLocal: {
            type: Boolean,
            default: false
        },
        data: {
            type: Array,
            required: false,
            default:()=>[]
        },
        // 常用标签的数据
        mostData: {
            type: Array,
            required: false,
            default: () => []
        },
        // 分组数据
        groupData: {
            type: Array,
            required: false,
            default: () => []
        },
        scrollbarClass: String,
        clearable: Boolean,
        // 是否父子关联 checked 生效
        checkStrictly: Boolean,
        // 隐藏分组父节点的多选框
        checkGroup: {
            type: Boolean,
            default: true
        },
        radioType: {
            type: String,
            default: ''
        },
        value: { required: true },
        // 数据分割符号
        seq: {
            type: String,
            default: ','
        },
        // 输出的数据类型
        outputFormat: {
            type: String,
            default: 'String',
            validator: function(val) {
                return ['String', 'Array'].indexOf(val) !== -1;
            }
        },
        // 过滤节点的方法
        filterNodeMethod: Function,
        // 可显示的类型
        visibleType: {
            type: String,
            default: 'all',
            validator: function(val) {
                return ['all', 'leaf', 'branch', 'all_with_indeterminate'].indexOf(val) !== -1;
            }
        },
        transferFilterable: {
            type: Boolean,
            default: true
        },
        transferClearable: {
            type: Boolean,
            default: true
        }
    },

    data() {
        return {
            tabKey: 'tree',
            // 数据源
            dataSource: this.data,
            // select 传值的搜索条件
            filterText: '',
            // 别名属性
            alias: {
                value: 'id',
                label: 'label',
                children: 'children',
                disabled: 'disabled',
                isLeaf: 'isLeaf'
            },
            // 是否处于编辑模式
            isEditing: false,
            innerMostData: this.mostData,
            // 追加常用和分组的翻译数据
            translateData: [],
            changedGroupData: null,
            debounceHandler: "",
            tmpRemoveKeys: []
        };
    },

    watch: {
        val: {
            handler(val, oldVal) {
                const keys = val == '' ? [] : val.split(',');
                const oldKeys = oldVal == '' ? [] : oldVal.split(',');
                const _this = this;
                const trees = _this.trees;
                const {value, label} = this.alias;


                if (_this.multiple) {
                    // 勾选/取消勾选
                    let isChecked = keys.length > oldKeys.length
                    // 勾选/取消前后的key差别
                    let difKeys = [];
                    if (isChecked) {
                        difKeys = _.difference(keys, oldKeys);
                        difKeys.map(newKey => {
                            const node = _this.$refs.select.getOption(newKey);
                            _this.useMost && _this.updateCheckCount({ [value]: node.value, [label]: node.label });
                        });
                    } else {
                        difKeys = _.difference(oldKeys, keys);
                    }
                    _this.groups.map(group => {
                        difKeys.map(key => {
                            _this.useGroup && _this.getRef('groupTree').setChecked(group + '---' + key, isChecked);
                        });
                    });

                    trees.map(item => {
                        if (item != 'groupTree') {
                            _this.getRef(item).setCheckedKeys(keys);
                        }
                    });
                } else {
                    trees.map(item => {
                        if (_this.tabKey == item) {
                        } else if (item != 'groupTree') {
                            _this.getRef(item).setCurrentKey(val);
                        } else {
                            let isFind = false;
                            for(let i = 0;i < _this.groups.length; i++){
                                let node = _this.getRef('groupTree').getNode(_this.groups[i] + '---' + val);
                                if(node){
                                    _this.getRef('groupTree').setCurrentKey(node.key);
                                    isFind = true;
                                    break;
                                }
                            }
                            if(!isFind){
                                _this.getRef('groupTree').setCurrentKey(null);
                            }
                        }
                    });
                    const node = _this.getRef('tree').getCurrentNode();
                    
                    _this.useMost && node && _this.updateCheckCount({ [value]: node[value], [label]: node[label] });
                }
            }
        },
        data: {
            deep: true,
            immediate: true,
            handler(val) {
                this.dataSource = val;

                this.$nextTick(() => {
                    // 同步下拉框值方法
                    this.syncSelectBoxValue();
                });
            }
        },
        props: {
            deep: true,
            immediate: true,
            handler(val) {
                this.alias = objectAssign(this.alias, val);
            }
        },
        filterText(val) {
            this.getRef(this.tabKey).filter(val);
        },
        tabKey(tabKey) {
            this.getRef(tabKey).filter(this.filterText);
        }
    },

    computed: {
        trees(){
            let treeList = ["tree"];
            this.useMost && treeList.push("mostTree");
            this.useGroup && treeList.push("groupTree");
            return treeList;
        },
        groups() {
            let dataSource = this.groupData;
            if(this.changedGroupData){
                dataSource = this.changedGroupData
            }else if(this.isLocal){
                dataSource = this._getLocalStorage("groupData");
            }
            return dataSource.map(group => group.id);
        },
        innerGroupData() {
            let dataSource = this.groupData;
            if(this.changedGroupData){
                dataSource = this.changedGroupData
            }else if(this.isLocal){
                dataSource = this._getLocalStorage("groupData");
            }

            return dataSource.map(item => {
                item.children.map(leaf => {
                    leaf.id = item.id + '---' + leaf.id;
                });
                return { ...item, disabled: false, originDisabled: item.disabled };
            });
        },
        /**
         * 选择框组件数据处理
         */
        val: {
            // 根据值，获取下拉框的展示标签
            get() {
                // 过滤数据
                const filterValue = this.translateValueToTags(this.value);

                return data2type(filterValue, 'String', this.seq);
            },
            set(value) {
                // 初始化
                const tree = this.getRef('tree');

                // 若为空值，则进行数据转化
                if (!value) value = [];

                // 树节点勾选
                tree.setCheckedKeys(value);

                // 树节点
                this.setTreeOrSelectData(value);
            }
        },

        /**
         * 滚动条样式
         *
         */
        scrollbarCls() {
            return 'dg-tree-select__scrollbar ' + this.scrollbarClass;
        },
        /**
         * 合并树节点的属性参数值
         *
         */
        treeBind() {
            return this._mergeTreeProps(this.treeProps);
        },
        groupTreeBind() {
            return this._mergeTreeProps(this.groupTreeProps);
        },
        /**
         * 合并树节点的属性参数值
         *
         */
        mostTreeBind() {
            return this._mergeTreeProps(this.mostTreeProps);
        },

        /**
         * 合并 select Props
         *
         */
        selectProp() {
            return objectAssign({}, this.$attrs, {
                disabled: this.disabled,
                multiple: this.multiple,
                clearable: this.clearable,
                seq: this.seq,
                'output-format': this.outputFormat,
                'filter-method': this.handleSelectFiler
            });
        }
    },

    created() {
        const _this = this;
        const { useMost, useGroup, mostData, groupData } = _this;
        const { value, label } = this.alias;
        useMost && this._initMostData();
        useGroup && this._initGroupData();
        mostData.map(item => {
            _this.translateData.push({ value: item[value], label: item[label] });
        });
        groupData.map(group => {
            group.children.map(item => {
                _this.translateData.push({ value: item[value], label: item[label] });
            });
        });
        this.translateData = _.uniqBy(this.translateData, 'value');
    },

    methods: {
        handleChangeNodeId(data){
            let tmpData = this.innerGroupData.find(item=>item.id==data.id)
            tmpData.id=data.newId
            this.getRef("editTree").handleChangeNodeId(this.innerGroupData)
        },
        /**
         * 初始化常用数据
         */
        _initMostData() {
            const _this = this;
            if (_this.isLocal) {
                _this.innerMostData = _this._getLocalStorage('mostData');
            }
            _this.innerMostData.sort((a, b) => b.count - a.count);

            if (this.useMost) {
                _this.$nextTick(() => {
                    const checkedKeys = _this.getRef('tree').getCheckedKeys();
                    _this.getRef('mostTree').setCheckedKeys(checkedKeys);
                });
            }
        },

        /**
         * 初始化分组数据
         */
        _initGroupData() {},
        /**
         * 获取需要渲染的tab
         */
        getShowTabs() {
            const _this = this;
            let result = [];
            const tabs = [
                {
                    tabKey: 'all',
                    label: '全部',
                    ref: 'tree',
                    data: _this.dataSource,
                    checkChange: _this.handleCheckChange
                },
                {
                    tabKey: 'most',
                    label: '常用',
                    ref: 'mostTree',
                    data: _this.innerMostData,
                    checkChange: _this.handleMostCheckChange,
                    renderContent: _this.renderMostContent
                },
                {
                    tabKey: 'group',
                    label: '分组',
                    ref: 'groupTree',
                    data: _this.innerGroupData,
                    checkChange: _this.handleGroupCheckChange
                }
            ];
            const { useGroup, useMost } = this;
            this.tabOrder.map(item => {
                if (item == 'group' && !useGroup) {
                } else if (item == 'most' && !useMost) {
                } else {
                    result.push(
                        tabs.find(tab => {
                            return tab.tabKey == item;
                        })
                    );
                }
            });
            return result;
        },
        /**
         * 合并树的pros属性
         */
        _mergeTreeProps(props) {
            return objectAssign({}, props, {
                data: this.dataSource,
                props: this.alias,
                'node-key': this.alias.value,
                'check-leaf': this.checkLeaf,
                'show-checkbox': this.radioType === '' && this.multiple,
                'radio-type': this.radioType,
                'filter-node-method': _.isFunction(this.filterNodeMethod) ? this.filterNodeMethod : this.filterNode,
                'check-strictly': this.checkStrictly,
                'highlight-current': true,
                'render-after-expand': false,
                'render-content': this.renderContent
            });
        },
        /**
         * 获取本地储存的数据
         */
        _getLocalStorage(key) {
            let dataStr = window.localStorage[this.chooseKey];
            let data = {};
            if (dataStr) {
                data = JSON.parse(dataStr);
            } else {
                return [];
            }
            return data[key] || [];
        },

        /**
         * 保存本地储存的数据
         */
        _setLocalStorage(data, key) {
            let dataSource = window.localStorage[this.chooseKey] || '{}';
            let tmpData = JSON.parse(dataSource);
            tmpData[key] = data;
            window.localStorage[this.chooseKey] = JSON.stringify(tmpData);
        },

        /**
         * 根据ref获取组件
         */
        getRef(name) {
            return this.$refs[name][0] || this.$refs[name];
        },

        // 当分组树更新时
        handleGroupTreeChange(data) {
            const _this = this;
            this.changedGroupData = data;
            if (_this.isLocal) {
                _this._setLocalStorage(this.changedGroupData, 'groupData');
            }
            _this.$emit('group-tree-change', JSON.parse(JSON.stringify(data)));
        },

        // 删除分组
        handleDeleteGroup(id) {
            !this.isLocal && this.$emit('delete-group', id);
        },

        // 保存分组
        handleSaveGroup(data) {
            const result = JSON.parse(JSON.stringify(data));
            !this.isLocal && this.$emit('save-group', result);
        },

        /**
         * 分组数据拖拽后触发事件
         */
        handleAfterGrag(groupData) {
            !this.isLocal && this.$emit('after-drag',  JSON.parse(JSON.stringify(groupData)));
        },

        /**
         * 检索值
         *
         * @param query [String] 查询文本
         */
        handleSelectFiler(query) {
            this.filterText = query;
        },

        /**
         * 设置树或选择框的事件触发
         *
         */
        setTreeOrSelectData(val) {
            // 初始化
            const { outputFormat, seq } = this;
            const tree = this.getRef('tree');

            // 值类型转化, 若是多选的话，val 的值为 []，需要值进行转化
            if (val && val.length === 0) val = '';

            // 更新缓存值
            this.filterTreeCacheVal = val;

            // 获取选中的树节点值
            const nodes = this.multiple ? tree.getCheckedNodes() : tree.getCurrentNode();

            let a = data2type(val, outputFormat, seq);
            // 触发 input or change 事件改变
            this.$emit('input', data2type(val, outputFormat, seq), nodes);
            this.$emit('change', data2type(val, outputFormat, seq), nodes);
        },

        /**
         * tree 过滤是否显示true or false
         *
         */
        filterNode(query = '', data) {
            if (!query) {
                return true;
            }

            const { label } = this.defaultProp;
            const labelValue = _.toUpper(data[label]);

            query = _.toUpper(query);

            if (labelValue.indexOf(query) !== -1) {
                return true;
            }

            let toPinyin = pinyin(labelValue, {
                heteronym: true, // 多音
                style: pinyin.STYLE_NORMAL // 无声调
            });

            if (toPinyin && toPinyin.length > 0) {
                let str = '';
                for (let key in toPinyin) {
                    str += toPinyin[key].join('');
                }
                str = _.toUpper(str);
                toPinyin = str;
            }

            return toPinyin.indexOf(query) !== -1;
        },

        /**
         * 置空 tree 选中状态
         *
         */
        handleSelectFilerClose(bool) {
            const { val } = this;
            if (bool) {
                /*
                    BUG描述
                        form reset 多触发选中，照成父组件数据的change
                    修复：
                        this.value === '' 下拉打开的时候判断，清空选中数据
                */
                if (_.isEmpty(val) || val.length < 1) {
                    this.clearDeaulf();
                }
            } else {
                this.filterText = '';
            }
        },

        /**
         * 清空检索值
         *
         */
        clearDeaulf() {
            const tree = this.getRef('tree');

            // 清空检索值
            this.filterText = '';

            if ([] instanceof Array) {
                return false;
            }

            // 清空选中数据及状态
            tree.setRadioKeys([]);
            tree.setCurrentKey(null);

            // 更新 value 值
            this.$emit('input', '');
        },

        /**
         * 查找所有的 key 值
         *
         * @param val [Boolean] true/false 是否过滤叶子节点
         * @param val [Array] data 返回节点的 key 值
         */
        allKeyValue(val, data) {
            // 初始化
            let _treeData = _.cloneDeep(data);
            let _treeAllKey = [];
            let self = this;

            // 递归获取所有的 key 值
            function getAllKeyValue(data) {
                // 初始化数据
                let _treeData = _.cloneDeep(data);

                _treeData.map(base => {
                    // 检测子节点数据是否存在
                    if (base[self.alias.children] && base[self.alias.children].length > 0) {
                        // 若存在，则进行递归，获取子节点
                        getAllKeyValue(base[self.alias.children]);
                    }

                    return base;
                });

                _treeData.forEach(item => {
                    if (val) {
                        if (item[self.alias.children] && item[self.alias.children].length > 0) {
                            _treeAllKey.push(item[self.alias.value]);
                        }
                    } else {
                        _treeAllKey.push(item[self.alias.value]);
                    }
                });
            }

            // 执行方法
            getAllKeyValue(_treeData);

            return _treeAllKey;
        },

        allKeyNodes(data) {
            // 初始化
            let _treeData = _.cloneDeep(data);
            let _treeAllKey = [];
            let self = this;

            // 递归获取所有的 key 值
            function getAllKeyValue(data) {
                // 初始化数据
                let _treeData = _.cloneDeep(data);

                _treeData.map(base => {
                    // 检测子节点数据是否存在
                    if (base.childNodes && base.childNodes.length > 0) {
                        // 若存在，则进行递归，获取子节点
                        getAllKeyValue(base.childNodes);
                    }

                    return base;
                });

                _treeData.forEach(item => {
                    _treeAllKey.push(item.key);
                });
            }

            // 执行方法
            getAllKeyValue(_treeData);

            return _treeAllKey;
        },

        /**
         * 转化 `value` 为标签值
         *
         */
        translateValueToTags(value) {
            // 若为空数据
            if (value === null) return '';

            // 验证值是否为空，是否为空数组，为全类型
            if (
                (typeof value === 'string' && !value) ||
                (typeof value === 'object' && value.length === 0) ||
                this.visibleType === 'all'
            ) {
                return value;
            }

            // 若是多选情况
            if (this.multiple && value) {
                // 初始化
                const tree = this.getRef('tree');
                const { visibleType, defaultProp } = this;
                const { value: keyId, children } = defaultProp;

                // 检测树的值
                if (!tree) return value;

                // 树选中的叶子节点值
                let checkedLeafKeys = tree.getCheckedKeys(true);
                // 树选中的节点值
                let checkedNodeKeys = tree.getCheckedKeys();
                // 比较之间的差值
                let diff = _.difference(checkedNodeKeys, checkedLeafKeys);
                // 值格式转化
                let formatValue = value.split(',');

                // 通过 value 值做检索过滤值
                switch (visibleType) {
                    // 叶子节点
                    case 'leaf': {
                        return _.difference(formatValue, diff);
                    }
                    // 枝干节点
                    case 'branch': {
                        // 检测是否懒加载
                        if (this.treeBind.lazy && this.multiple) {
                            const allNodes = tree.getCheckedNodes(false, false);
                            let treeNodes = tree.store.root.childNodes;

                            const diffNodes = nodes => {
                                let child = [];
                                const flatter = arr => {
                                    arr.forEach(item => {
                                        if (item.checked) {
                                            child.push(item);
                                        } else {
                                            child.push(item);
                                            if (item.childNodes && item.childNodes.length) {
                                                flatter(item.childNodes);
                                            }
                                        }
                                    });
                                };

                                // 枝干节点过滤
                                flatter(nodes);
                                return child;
                            };
                            let branchOrLeafNodeKeys = diffNodes(treeNodes).map(item => item.key);
                            let branchOtherDiff = _.difference(checkedNodeKeys, branchOrLeafNodeKeys);

                            return _.difference(formatValue, branchOtherDiff);
                        } else {
                            const allNodes = tree.getCheckedNodes(false, false);

                            const diffNodes = allNodes => {
                                let child = [];
                                let del = []; // 剔除的id
                                // 去掉重复的选中项
                                const flatter = arr => {
                                    arr.forEach(item => {
                                        const index = _.findIndex(child, { [keyId]: item[keyId] });
                                        if (index > -1) {
                                            del = del.concat(child.splice(index, 1));
                                        } else {
                                            const delIndex = _.findIndex(del, { [keyId]: item[keyId] });
                                            if (delIndex === -1) {
                                                child.push(item);
                                            }
                                        }
                                        if (item[children] && item[children].length) {
                                            flatter(item[children]);
                                        }
                                    });
                                };
                                flatter(allNodes);
                                return child;
                            };
                            let branchOrLeafNodeKeys = diffNodes(allNodes).map(item => item[keyId]);
                            let branchOtherDiff = _.difference(checkedNodeKeys, branchOrLeafNodeKeys);

                            return _.difference(formatValue, branchOtherDiff);
                        }
                    }
                    default: {
                        return formatValue;
                    }
                }
            }

            return value;
        },

        /**
         * 响应分组树选中事件
         */
        handleGroupCheckChange(obj, checked, indeterminate) {
            this._handleCheckChange(obj, checked, indeterminate, 'groupTree');
        },

        /**
         * 响应常用树选中事件
         */
        handleMostCheckChange(obj, checked, indeterminate) {
            this._handleCheckChange(obj, checked, indeterminate, 'mostTree');
        },

        _handleCheckChange(data, checked, indeterminate, ref) {
            let value = data2type(this.value, 'String', this.seq);
            let id = data.id;
            const _this = this;
            var _seq = this.seq,
                outputFormat = this.outputFormat;
            if (id.includes('---')) {
                id = id.split('---')[1];
            }

            var _data = this.getRef(ref).getCheckedKeys(false);
            _data = _data.map(item => {
                if (item.includes('---')) {
                    item = item.split('---')[1];
                }
                return item;
            });

            if(!checked && ref == "groupTree"){
                let tmpKeys = data.id.split("---")
                if(tmpKeys.length>1){
                    this.tmpRemoveKeys.push(tmpKeys[1])
                }
            }

            value && (_data = _data.concat(value.split(_seq)));
            // 去重
            _data = _.uniq(_data);
            // 过滤分组
            _data = _.difference(_data, this.groups);

            if (!checked) {
                _data = _data.filter(item => item != id);
            }
            
            if(this.debounceHandler){
                clearTimeout(this.debounceHandler)
            }
            this.debounceHandler = setTimeout(()=>{
                let resultKeys = data2type(_data, outputFormat, _seq)
                let type = typeof resultKeys;
                if(type === "string"){
                    resultKeys = _.difference(resultKeys.split(_seq), _this.tmpRemoveKeys);
                    resultKeys = resultKeys.join(_seq)
                }else{
                    resultKeys = _.difference(resultKeys, _this.tmpRemoveKeys);
                }
                _this.tmpRemoveKeys = [];
                this.$emit('input', resultKeys);

                this.$emit('check-change', data, checked, indeterminate);
            },50);
        },

        handleCheckChange(data, checked, indeterminate) {
            let value = data2type(this.value, 'String', this.seq);

            // 若存在缓存值，则原先不归属于树节点（懒加载情况下），则进行追加文本显示
            if (this.treeBind.lazy && this.multiple) {
                // 正则表达式，是否存在 "," 分割
                let reg = /^.*[\,,].*$/;
                // 缓存字段数据
                let cacheArray = [];

                if (value) {
                    // 缓存字段是否为多个数据
                    if (reg.test(value)) {
                        cacheArray = value.split(',');
                    } else {
                        cacheArray.push(value);
                    }
                }

                // 选中字段
                if (checked) {
                    let selectedTreeKeys = this.getRef('tree').getCheckedKeys(false);
                    let coopArray = _.concat(selectedTreeKeys, cacheArray);
                    cacheArray = _.uniq(coopArray);
                } else {
                    let nodes = this.getRef('tree').getNode(data);
                    let selectedTreeKeys = this.getRef('tree').getCheckedKeys(false);
                    let filterArray = this.allKeyNodes(nodes.childNodes);
                    filterArray.push(nodes.key);
                    cacheArray = _.concat(cacheArray, selectedTreeKeys);
                    cacheArray = _.uniq(cacheArray);
                    filterArray = _.difference(filterArray, selectedTreeKeys);
                    cacheArray = _.difference(cacheArray, filterArray);
                    cacheArray = cacheArray ? cacheArray : [];
                }

                if(this.tabKey === "tree"){
                    this.$emit('input', data2type(cacheArray, 'String', this.seq));

                    this.$emit('check-change', data, checked, indeterminate);
                }
            } else {
                var _seq = this.seq,
                    outputFormat = this.outputFormat;

                var _data = this.getRef('tree').getCheckedKeys(false);
                    
                if(this.tabKey === "tree"){
                    this.$emit('input', data2type(_data, outputFormat, _seq));

                    this.$emit('check-change', data, checked, indeterminate);
                }
            }
        },

        /**
         * 更新点击次数
         * 如果常用列表没有该节点，则新增一个
         */
        updateCheckCount(data) {
            const _this = this;
            const {value, label} = _this.alias;

            let tmpObj = _this.innerMostData.find(item => {
                return item.id === data.id;
            });
            if (tmpObj) {
                tmpObj.count += 1;
            } else {
                _this.innerMostData.push({ checked: true, [value]: data[value], [label]: data[label], count: 1 });
            }

            if (_this.isLocal) {
                // 保存数据
                const mostData = _this.innerMostData.map(item => {
                    return { [value]: item[value], [label]: item[label], count: item.count };
                });
                _this._setLocalStorage(mostData, 'mostData');
            }

            _this.$nextTick(() => {
                if (_this.multiple) {
                    _this.useMost && _this.getRef('mostTree').setChecked(data.id, true);
                } else {
                    _this.useMost && _this.getRef('mostTree').setCurrentKey(data.id);
                }
                this.sortMostTree();
            });
            const result = _this.innerMostData.find(item => item.id == data.id)
            
            _this.$emit('add-click-times', JSON.parse(JSON.stringify(result)));
        },

        /**
         * 树节点点击事件
         */
        handleNodeClick(obj, node) {
            const _this = this;
            if (_this.multiple) {
                return false;
            }
            if(this.tabKey == "groupTree" && !obj.id.includes('---')){
                _this.val = [""];
                _this.useGroup && _this.getRef("groupTree").setCurrentKey(null);
                _this.useMost && _this.getRef("mostTree").setCurrentKey(null);
                _this.getRef("tree").setCurrentKey(null);
            }
            if (obj.id.includes('---')) {
                _this.val = [obj.id.split('---')[1]];
            }
        },

        /**
         * 更新常用树排序
         */
        sortMostTree() {
            const _this = this;
            let keys = '';
            if (_this.multiple) {
                keys = this.getRef('mostTree').getCheckedKeys();
            } else {
                keys = this.getRef('mostTree').getCurrentKey();
            }
            let bakData = _this.innerMostData;
            bakData.sort((a, b) => {
                return b.count - a.count;
            });
            _this.innerMostData = [];

            bakData.map(item => {
                _this.innerMostData.push(item);
            });
            _this.$nextTick(() => {
                if (_this.multiple) {
                    _this.getRef('mostTree').setCheckedKeys(keys, true);
                } else {
                    _this.getRef('mostTree').setCurrentKey(keys);
                }
            });
        },

        renderMostContent(h, { node, data, store }) {
            const { label } = this.defaultProp;
            return (
                <span class="el-tree-node__label">
                    <span>{data[label]}</span>
                    <span style="margin: 0 4px;">({data.count})</span>
                </span>
            );
        },

        // 渲染 option 到 tree
        renderContent(h, { node, data, store }) {
            const { label, value, disabled } = this.defaultProp;

            return h(LOption, {
                props: {
                    key: data[value],
                    label: data[label],
                    value: data[value],
                    disabled: data[disabled],
                    isHighLight: node.store.isHighLight,
                    filter: node.filter
                }
            });
        },

        // 同步下拉框值方法
        syncSelectBoxValue() {
            const { seq } = this;
            const value = data2type(this.value, 'String', seq);
            const { radioType, showCheckbox, itemsWithDisabled, nodeKey, checkStrictly } = this.getRef('tree');
            const valArr = str2arr(value, seq, true, itemsWithDisabled, nodeKey);

            // radio
            if (radioType === 'level' || radioType === 'all') {
                this.getRef('tree').setRadioKeys(valArr);
            }

            // checkbox
            if (showCheckbox) {
                const preCheckedArr = this.getRef('tree').getCheckedKeys();
                const oldValArr = str2arr(preCheckedArr, seq);

                if (valArr.length && oldValArr.length && !checkStrictly) {
                    const diffArr = _.difference(oldValArr, valArr);

                    // 剔除父及祖先级元素
                    const traverseParent = function(node, valArr) {
                        const parentNode = node.parent;
                        if (parentNode && parentNode.level != 0) {
                            _.remove(valArr, n => parentNode.data[nodeKey] === n);
                            traverseParent(parentNode, valArr);
                        }
                    };

                    // 剔除所有子代及子孙元素
                    const traverseChild = function(node, valArr) {
                        const childNodes = node.childNodes;
                        if (childNodes && childNodes.length) {
                            childNodes.forEach(item => {
                                _.remove(valArr, n => n === item.data[nodeKey]);
                            });
                            traverseChild(childNodes, valArr);
                        }
                    };

                    diffArr.forEach(item => {
                        const node = this.getRef('tree').getNode(item);
                        if (node) {
                            traverseParent(node, valArr);
                            traverseChild(node, valArr);
                        }
                    });
                }
                this.getRef('tree').setCheckedKeys(valArr);
            }

            // highlight
            if (!showCheckbox && radioType === '' && valArr.length < 2) {
                this.getRef('tree').setCurrentKey(valArr);
            }
        },
        // 删除标签
        handleRemoveTag(val) {
            this.getRef('tree').setChecked(val, false, true);
        },
        ...TreeRefs
    }
};
</script>

