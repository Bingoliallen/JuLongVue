<template>
    <div class="el-tree-node dg-tree-node" @click.stop="handleClick"
        @contextmenu="$event => this.handleContextMenu($event)" v-show="node.visible" :class="{
            'is-expanded': expanded,
            'is-current': tree.store.currentNode === node,
            'is-hidden': !node.visible,
            'is-focusable': !node.disabled,
            'is-checked': !node.disabled && node.checked,
            'is-radio': node.disabled && !node.checked && !checkStrictly
        }" role="treeitem" tabindex="-1" :aria-expanded="expanded" :aria-disabled="node.disabled"
        :aria-checked="node.checked" :draggable="tree.draggable" @dragstart.stop="handleDragStart"
        @dragover.stop="handleDragOver" @dragend.stop="handleDragEnd" @drop.stop="handleDrop" ref="node">
        <div class="el-tree-node__content" :style="{ 'padding-left': (node.level - 1) * tree.indent + 'px' }">
            <span @click.stop="handleExpandIconClick" :class="[
                    {
                        'is-leaf': node.isLeaf,
                        expanded: !node.isLeaf && expanded
                    },
                    'el-tree-node__expand-icon',
                    tree.iconClass ? node.isLeaf ? (tree.iconLeaf ? tree.iconLeaf : '') : tree.iconClass : 'el-icon-caret-right'
                ]"></span>
            <el-checkbox v-if="showCheckbox && !(node.store.isFrozenRoot && node.level === 1)" v-model="node.checked"
                :indeterminate="node.indeterminate" :disabled="!!node.disabled" @click.native.stop
                @change="handleCheckChange"></el-checkbox>
            <dg-radio v-else-if="radioType" v-model="node.radio" :label="node.data[nodeKey]" :disabled="!!node.disabled"
                @change="handleRadioChange">
                <span></span>
            </dg-radio>
            <span v-if="node.loading" class="el-tree-node__loading-icon el-icon-loading"></span>
            <node-content :node="node"></node-content>
        </div>
        <el-collapse-transition>
            <div class="el-tree-node__children" v-if="!renderAfterExpand || childNodeRendered" v-show="expanded"
                role="group" :aria-expanded="expanded">
                <el-tree-node :node-key="nodeKey" :check-strictly="checkStrictly" :radio-type="radioType"
                    :render-content="renderContent" v-for="child in node.childNodes"
                    :render-after-expand="renderAfterExpand" :show-checkbox="showCheckbox" :key="getNodeKey(child)"
                    :node="child" @node-expand="handleChildNodeExpand"></el-tree-node>
            </div>
        </el-collapse-transition>
    </div>
</template>

<script type="text/jsx">
    import ElCollapseTransition from 'main/transitions/collapse-transition';
import { Checkbox as ElCheckbox } from 'element-ui';
import DgRadio from 'packages/radio';
import emitter from 'main/mixins/emitter';
import { getNodeKey } from './model/util';
import { data2type } from 'main/dg-utils/data-convert.js';

export default {
    name: 'ElTreeNode',

    componentName: 'ElTreeNode',

    mixins: [emitter],

    props: {
        // create author:lutz
        checkStrictly: Boolean,
        node: {
            default() {
                return {};
            }
        },
        radioType: String,
        nodeKey: String,
        props: {},
        renderContent: Function,
        renderAfterExpand: {
            type: Boolean,
            default: true
        },
        showCheckbox: {
            type: Boolean,
            default: false
        }
    },

    components: {
        ElCollapseTransition,
        DgRadio,
        ElCheckbox,
        NodeContent: {
            props: {
                node: {
                    required: true
                }
            },
            render(h) {
                const parent = this.$parent;
                const tree = parent.tree;
                const node = this.node;
                const { data, store } = node;

                // add author: tangdm 增加过滤值高亮
                const temple = node.store.isHighLight && node.filter ? node.label.replace(
                    new RegExp(node.filter + '{1}'),
                    `<span class="dg-tree-filter__light">${node.filter}</span>`
                ) : node.label;

                return parent.renderContent ? (
                    parent.renderContent.call(parent._renderProxy, h, { _self: tree.$vnode.context, node, data, store })
                ) : tree.$scopedSlots.default ? (
                    tree.$scopedSlots.default({ node, data })
                ) : (
                    // update author: tangdm desc: 支持 `v-html` 模板语法，用于支持高亮检索词
                    // <span class="el-tree-node__label">{node.label}</span>
                    <span class="el-tree-node__label" domPropsInnerHTML={temple}></span>
                );
            }
        }
    },

    data() {
        return {
            tree: null,
            expanded: false,
            childNodeRendered: false,
            oldChecked: null,
            oldIndeterminate: null
        };
    },

    watch: {
        'node.indeterminate'(val) {
            this.handleSelectChange(this.node.checked, val);
        },

        'node.checked'(val) {
            this.handleSelectChange(val, this.node.indeterminate);
        },

        'node.expanded'(val) {
            this.$nextTick(() => (this.expanded = val));
            if (val) {
                this.childNodeRendered = true;
            }
        }
    },

    methods: {
        getNodeKey(node) {
            return getNodeKey(this.tree.nodeKey, node.data);
        },

        handleSelectChange(checked, indeterminate, bool) {
            if (this.oldChecked !== checked && this.oldIndeterminate !== indeterminate) {
                this.tree.$emit('check-change', this.node.data, checked, indeterminate);
                // create-start author:lutz  checkbox的v-model
                const { seq, outputFormat } = this.tree;
                const data = this.tree.getCheckedKeys(false);
                this.tree.$emit('input', data2type(data, outputFormat, seq));
                // create-end
            }
            this.oldChecked = checked;
            this.indeterminate = indeterminate;
        },

        handleClick() {
            // create-start 单选禁用的情况展开子元素
            if (this.node.disabled && !this.node.checked) {
                this.handleExpandIconClick();
                return;
            }
            // create-end
            const store = this.tree.store;
            store.setCurrentNode(this.node);
            this.tree.$emit('current-change', store.currentNode ? store.currentNode.data : null, store.currentNode);
            this.tree.currentNode = this;
            if (this.tree.expandOnClickNode) {
                this.handleExpandIconClick();
            }

            if (this.tree.checkOnClickNode && !this.node.disabled) {
                this.handleCheckChange(null, {
                    target: { checked: !this.node.checked }
                });
            }

            // create-start author:lutz 普通单选的v-model
            // !showCheckbox && radioType === '' 非复选框的情况
            if (!this.showCheckbox && this.tree.radioType === '' && !this.node.disabled) {
                const { seq, outputFormat } = this.tree;
                const data = this.node.data[this.nodeKey];
                const outVal = data2type(data, outputFormat, seq);
                this.tree.$emit('input', data2type(data, outputFormat, seq));
                this.dispatch('LSelect', 'handleCloseDrapdown');
            }
            // create-end

            this.tree.$emit('node-click', this.node.data, this.node, this);
        },

        handleContextMenu(event) {
            if (this.tree._events['node-contextmenu'] && this.tree._events['node-contextmenu'].length > 0) {
                event.stopPropagation();
                event.preventDefault();
            }
            this.tree.$emit('node-contextmenu', event, this.node.data, this.node, this);
        },

        handleExpandIconClick() {
            if (this.node.isLeaf) return;
            if (this.expanded) {
                this.tree.$emit('node-collapse', this.node.data, this.node, this);
                this.node.collapse();
            } else {
                this.node.expand();
                this.$emit('node-expand', this.node.data, this.node, this);
            }
        },

        handleCheckChange(value, ev) {
            // 通过勾选的值，判断父子节点是否关联
            let node = this.node;
            let checked;

            // add author: tangdm desc: 增加判断是否展开关联或收缩不关联
            // if(node.store.isToggleContact) {
            //     checked = node.expanded ? (node.checked === value && node.selected ? !value : value) : value;
            // } else {
                checked = ev.target.checked;
            // }

            this.node.setChecked(checked, !this.tree.checkStrictly);
            this.$nextTick(() => {
                const store = this.tree.store;
                this.tree.$emit('check', this.node.data, {
                    checkedNodes: store.getCheckedNodes(),
                    checkedKeys: store.getCheckedKeys(),
                    halfCheckedNodes: store.getHalfCheckedNodes(),
                    halfCheckedKeys: store.getHalfCheckedKeys()
                });
            });
        },

        handleChildNodeExpand(nodeData, node, instance) {
            this.broadcast('ElTreeNode', 'tree-node-expand', node);
            this.tree.$emit('node-expand', nodeData, node, instance);
        },

        handleDragStart(event) {
            if (!this.tree.draggable) return;
            this.tree.$emit('tree-node-drag-start', event, this);
        },

        handleDragOver(event) {
            if (!this.tree.draggable) return;
            this.tree.$emit('tree-node-drag-over', event, this);
            event.preventDefault();
        },

        handleDrop(event) {
            event.preventDefault();
        },

        handleDragEnd(event) {
            if (!this.tree.draggable) return;
            this.tree.$emit('tree-node-drag-end', event, this);
        },

        // lutz+
        /* 当单选框被点击的时候触发 $emit('radio', node.data: object, { radioNodes: array, radioKeys: array }) */
        handleRadioChange(val) {
            this.$nextTick(() => {
                const store = this.tree.store;

                if (this.radioType === 'level') {
                    this.node.parent.childNodes.forEach(node => node.setRadio(null));
                } else {
                    const allNodes = store._getAllNodes().sort((a, b) => b.level - a.level);
                    allNodes.forEach(node => node.setRadio(null));
                }

                this.node.setRadio(val);
                const radioKeys = store.getRadioKeys();
                this.tree.$emit('radio', this.node.data, { radioNodes: store.getRadioNodes(), radioKeys });

                const { seq, outputFormat } = this.tree;

                this.tree.$emit('input', data2type(radioKeys, outputFormat, seq));
                if (this.radioType !== 'level') {
                    this.dispatch('LSelect', 'handleCloseDrapdown');
                }
            });
        }
        // lutz-
    },

    created() {
        const parent = this.$parent;

        if (parent.isTree) {
            this.tree = parent;
        } else {
            this.tree = parent.tree;
        }

        const tree = this.tree;
        if (!tree) {
            console.warn("Can not find node's tree.");
        }

        const props = tree.props || {};
        const childrenKey = props['children'] || 'children';

        this.$watch(`node.data.${childrenKey}`, () => {
            this.node.updateChildren();
        });

        if (this.node.expanded) {
            this.expanded = true;
            this.childNodeRendered = true;
        }

        if (this.tree.accordion) {
            this.$on('tree-node-expand', node => {
                if (this.node !== node) {
                    this.node.collapse();
                }
            });
        }
    }
};
</script>