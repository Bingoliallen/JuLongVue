<!--
    1. v-modal
    2. radio
        a) 同级单选
        b) 树单选
    3. 复选框单选
    4. 数据源处理
-->

<template>
    <div role="tree" class="el-tree dg-tree" :class="{
            'el-tree--highlight-current': highlightCurrent,
            'is-dragging': !!dragState.draggingNode,
            'is-drop-not-allow': !dragState.allowDrop,
            'is-drop-inner': dragState.dropType === 'inner',
            'dg-tree--icon-class-style': iconClass
        }">
        <!-- update
        author:lutz
        code:
            :props="props"
    -->

        <el-tree-node v-for="child in root.childNodes" :node="child" :props="defaultProp" :node-key="nodeKey"
            :check-strictly="checkStrictly" :render-after-expand="renderAfterExpand" :show-checkbox="showCheckbox"
            :radio-type="radioType" :key="getNodeKey(child)" :render-content="renderContent"
            @node-expand="handleNodeExpand"></el-tree-node>
        <div class="el-tree__empty-block" v-if="isEmpty">
            <span class="el-tree__empty-text">{{ emptyText }}</span>
        </div>
        <div v-show="dragState.showDropIndicator" class="el-tree__drop-indicator" ref="dropIndicator"></div>
    </div>
</template>

<script>
    import _ from 'lodash';
    import {
        Tree as ElTree
    } from 'element-ui';
    import ElTreeNode from './tree-node.vue';
    import TreeStore from './model/tree-store';
    import {
        findNearestComponent
    } from './model/util';
    import {
        addClass,
        removeClass
    } from 'main/utils/dom';
    import itemsWithDisabled from 'main/dg-mixins/itemsWithDisabled.js';
    import {
        complex
    } from 'main/dg-utils/shear.js';
    import {
        str2arr,
        uniqArr
    } from 'main/dg-utils/data-convert.js';
    const Tree = complex(ElTree, ['created', 'mounted']);

    export default {
        name: 'DgTree',

        mixins: [Tree, itemsWithDisabled],

        components: {
            ElTreeNode
        },

        props: {
            iconLeaf: String,
            iconClass: String,
            // 只能选择叶子节点
            checkLeaf: Boolean,
            // node-key 现在是必须的
            nodeKey: {
                type: String,
                required: true
            },
            value: {
                type: [String, Array, Number]
            },
            // element-ui 高亮显示选中
            highlightCurrent: {
                type: Boolean,
                default () {
                    return true;
                }
            },
            // radio: all：整棵树只能选一个; level：同级只能选择一个; '': 不显示默认
            radioType: {
                type: String,
                default: '',
                validator: function (val) {
                    return ['level', 'all', ''].indexOf(val) !== -1;
                }
            },
            // 是否移除默认的键盘监听事件
            noneDefaultKeyboard: {
                type: Boolean,
                default: false
            },
            // 是否在复选的模式支持展开关联且收缩失去关联 add author: tangdm
            isToggleContact: {
                type: Boolean,
                default: false
            },
            // 是否根节点冻结 add author: tangdm
            isFrozenRoot: {
                type: Boolean,
                default: false
            },
            // 是否高亮检索值 add author: tangdm
            isHighLight: {
                type: Boolean,
                default: false
            },
        },
        watch: {
            // create author:lutz
            // v-model 功能绑定数据
            value(val, oldVal) {
                // debugger;
                const {
                    radioType,
                    seq,
                    value,
                    showCheckbox,
                    itemsWithDisabled,
                    nodeKey
                } = this;
                const valArr = str2arr(value, seq, true, itemsWithDisabled, nodeKey);

                // radio
                if (radioType === 'level' || radioType === 'all') {
                    this.setRadioKeys(valArr);
                }

                // checkbox
                if (showCheckbox) {
                    const {
                        checkStrictly
                    } = this;
                    const preCheckedArr = this.getCheckedKeys();
                    const oldValArr = str2arr(preCheckedArr, seq);

                    if (valArr.length && oldValArr.length && !checkStrictly) {
                        const {
                            nodeKey
                        } = this;
                        const diffArr = _.difference(oldValArr, valArr);

                        // 剔除父及祖先级元素
                        const traverseParent = function (node, valArr) {
                            const parentNode = node.parent;
                            if (parentNode && parentNode.level != 0) {
                                _.remove(valArr, n => parentNode.data[nodeKey] === n);
                                traverseParent(parentNode, valArr);
                            }
                        };

                        // 剔除所有子代及子孙元素
                        const traverseChild = function (node, valArr) {
                            const childNodes = node.childNodes;
                            if (childNodes && childNodes.length) {
                                childNodes.forEach(item => {
                                    _.remove(valArr, n => n === item.data[nodeKey]);
                                });
                                traverseChild(childNodes, valArr);
                            }
                        };

                        // diffArr.forEach(item => {
                        //     const node = this.getNode(item);
                        //     if (node) {
                        //         traverseParent(node, valArr);
                        //         traverseChild(node, valArr);
                        //     }
                        // });
                    }
                    this.setCheckedKeys(valArr);
                }

                // highlight
                if (!showCheckbox && radioType === '' && valArr.length < 2) {
                    this.setCurrentKey(valArr);
                }
            },

            // create author:lutz
            dataSource(val) {
                this.store.setData(this.itemsWithDisabled);
            }
        },

        // describe:数据类型转换
        created() {
            console.log(this.value)
            this.isTree = true;
            // create-start author:lutz
            const valArr = str2arr(this.value, this.seq, true, this.dataSource);
            const checkArr = str2arr(this.defaultCheckedKeys, this.seq, true, this.dataSource, this.nodeKey);
            const expArr = str2arr(this.defaultExpandedKeys, this.seq, true, this.dataSource, this.nodeKey);
            // create-end author:lutz
            this.store = new TreeStore({
                key: this.nodeKey,
                lazy: this.lazy,
                load: this.load,
                checkLeaf: this.checkLeaf,
                checkStrictly: this.checkStrictly || this.isToggleContact,
                // add author: tangdm desc: 收缩展开是否联动
                isToggleContact: this.isToggleContact,
                // add author: tangdm desc: 是否冻结根节点
                isFrozenRoot: this.isFrozenRoot,
                // add author: tangdm desc: 是否高亮检索值
                isHighLight: this.isHighLight,

                checkDescendants: this.checkDescendants,
                // update-start  author:lutz
                data: this.dataSource,
                radioType: this.radioType,
                props: this.defaultProp,
                currentNodeKey: this.currentNodeKey || this.value,
                defaultCheckedKeys: uniqArr(valArr, checkArr),
                defaultExpandedKeys: uniqArr(valArr, expArr),
                /* [code]
                    data: this.data,
                    props: this.props,
                    currentNodeKey: this.currentNodeKey
                    defaultCheckedKeys: this.defaultCheckedKeys,
                    defaultExpandedKeys: this.defaultExpandedKeys
                */
                // update-end
                autoExpandParent: this.autoExpandParent,
                defaultExpandAll: this.defaultExpandAll,
                filterNodeMethod: this.filterNodeMethod
            });

            this.root = this.store.root;

            let dragState = this.dragState;

            this.$on('tree-node-drag-start', (event, treeNode) => {
                if (typeof this.allowDrag === 'function' && !this.allowDrag(treeNode.node)) {
                    event.preventDefault();
                    return false;
                }
                event.dataTransfer.effectAllowed = 'move';

                // wrap in try catch to address IE's error when first param is 'text/plain'
                try {
                    // setData is required for draggable to work in FireFox
                    // the content has to be '' so dragging a node out of the tree won't open a new tab in FireFox
                    event.dataTransfer.setData('text/plain', '');
                } catch (e) {}
                dragState.draggingNode = treeNode;
                this.$emit('node-drag-start', treeNode.node, event);
            });

            this.$on('tree-node-drag-over', (event, treeNode) => {
                const dropNode = findNearestComponent(event.target, 'ElTreeNode');
                const oldDropNode = dragState.dropNode;
                if (oldDropNode && oldDropNode !== dropNode) {
                    removeClass(oldDropNode.$el, 'is-drop-inner');
                }
                const draggingNode = dragState.draggingNode;
                if (!draggingNode || !dropNode) return;

                let dropPrev = true;
                let dropInner = true;
                let dropNext = true;
                let userAllowDropInner = true;
                if (typeof this.allowDrop === 'function') {
                    dropPrev = this.allowDrop(draggingNode.node, dropNode.node, 'prev');
                    userAllowDropInner = dropInner = this.allowDrop(draggingNode.node, dropNode.node, 'inner');
                    dropNext = this.allowDrop(draggingNode.node, dropNode.node, 'next');
                }
                event.dataTransfer.dropEffect = dropInner ? 'move' : 'none';
                if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {
                    if (oldDropNode) {
                        this.$emit('node-drag-leave', draggingNode.node, oldDropNode.node, event);
                    }
                    this.$emit('node-drag-enter', draggingNode.node, dropNode.node, event);
                }

                if (dropPrev || dropInner || dropNext) {
                    dragState.dropNode = dropNode;
                }

                if (dropNode.node.nextSibling === draggingNode.node) {
                    dropNext = false;
                }
                if (dropNode.node.previousSibling === draggingNode.node) {
                    dropPrev = false;
                }
                if (dropNode.node.contains(draggingNode.node, false)) {
                    dropInner = false;
                }
                if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {
                    dropPrev = false;
                    dropInner = false;
                    dropNext = false;
                }

                const targetPosition = dropNode.$el.getBoundingClientRect();
                const treePosition = this.$el.getBoundingClientRect();

                let dropType;
                const prevPercent = dropPrev ? (dropInner ? 0.25 : dropNext ? 0.45 : 1) : -1;
                const nextPercent = dropNext ? (dropInner ? 0.75 : dropPrev ? 0.55 : 0) : 1;

                let indicatorTop = -9999;
                const distance = event.clientY - targetPosition.top;
                if (distance < targetPosition.height * prevPercent) {
                    dropType = 'before';
                } else if (distance > targetPosition.height * nextPercent) {
                    dropType = 'after';
                } else if (dropInner) {
                    dropType = 'inner';
                } else {
                    dropType = 'none';
                }

                const iconPosition = dropNode.$el.querySelector('.el-tree-node__expand-icon')
                    .getBoundingClientRect();
                const dropIndicator = this.$refs.dropIndicator;
                if (dropType === 'before') {
                    indicatorTop = iconPosition.top - treePosition.top;
                } else if (dropType === 'after') {
                    indicatorTop = iconPosition.bottom - treePosition.top;
                }
                dropIndicator.style.top = indicatorTop + 'px';
                dropIndicator.style.left = iconPosition.right - treePosition.left + 'px';

                if (dropType === 'inner') {
                    addClass(dropNode.$el, 'is-drop-inner');
                } else {
                    removeClass(dropNode.$el, 'is-drop-inner');
                }

                dragState.showDropIndicator = dropType === 'before' || dropType === 'after';
                dragState.allowDrop = dragState.showDropIndicator || userAllowDropInner;
                dragState.dropType = dropType;
                this.$emit('node-drag-over', draggingNode.node, dropNode.node, event);
            });

            this.$on('tree-node-drag-end', event => {
                const {
                    draggingNode,
                    dropType,
                    dropNode
                } = dragState;
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';

                if (draggingNode && dropNode) {
                    const draggingNodeCopy = {
                        data: draggingNode.node.data
                    };
                    if (dropType !== 'none') {
                        draggingNode.node.remove();
                    }
                    if (dropType === 'before') {
                        dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);
                    } else if (dropType === 'after') {
                        dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);
                    } else if (dropType === 'inner') {
                        dropNode.node.insertChild(draggingNodeCopy);
                    }
                    if (dropType !== 'none') {
                        this.store.registerNode(draggingNodeCopy);
                    }

                    removeClass(dropNode.$el, 'is-drop-inner');

                    this.$emit('node-drag-end', draggingNode.node, dropNode.node, dropType, event);
                    if (dropType !== 'none') {
                        this.$emit('node-drop', draggingNode.node, dropNode.node, dropType, event);
                    }
                }
                if (draggingNode && !dropNode) {
                    this.$emit('node-drag-end', draggingNode.node, null, dropType, event);
                }

                dragState.showDropIndicator = false;
                dragState.draggingNode = null;
                dragState.dropNode = null;
                dragState.allowDrop = true;
            });
        },

        methods: {
            /*  radioType: 1. all：整棵树只能选一个 2. level：同级只能选择一个 3. '': 不显示默认 */
            // 返回目前被选中的节点所组成的数组
            getRadioNodes() {
                return this.store.getRadioNodes();
            },

            // 返回目前被选中的节点所组成的数组的 key
            getRadioKeys() {
                return this.store.getRadioKeys();
            },

            // 设置目前勾选的节点，使用此方法必须设置 node-key 属性。function (nodes: array)
            setRadioNodes(nodes) {
                if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setRadioNodes');
                this.store.setRadioNodes(nodes);
            },

            // 设置勾选节点所组成的数组的 key。 function(keys: array)
            setRadioKeys(keys) {
                if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setRadioKeys');
                this.store.setRadioKeys(keys);
            },

            // 设置radio信息。 function (data: array, radioVal: boolean, deep: boolean = false)
            setRadio(data, radioVal, deep) {
                this.store.setRadio(data, radioVal, deep);
            }
        },

        // edit author: tangdm descript: 去除默认的鼠标监听事件
        mounted() {
            this.initTabIndex();
            if (!this.noneDefaultKeyboard) this.$el.addEventListener('keydown', this.handleKeydown);
        },

        updated() {
            this.treeItems = this.$el.querySelectorAll('[role=treeitem]');
            this.checkboxItems = this.$el.querySelectorAll('input[type=checkbox]');
        }
    };
</script>