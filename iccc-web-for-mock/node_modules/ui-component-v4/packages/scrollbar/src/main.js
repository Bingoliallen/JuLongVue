// reference https://github.com/noeldelgado/gemini-scrollbar/blob/master/index.js

import { addResizeListener, removeResizeListener } from "main/utils/resize-event";
import scrollbarWidth from "main/utils/scrollbar-width";
import { toObject } from "main/utils/util";
import Bar from "./bar";
import $ from "jquery";

/* istanbul ignore next */
export default {
    name: "DgScrollbar",

    components: { Bar },

    props: {
        native: Boolean,
        wrapStyle: {},
        wrapClass: {},
        viewClass: {},
        viewStyle: {},
        noresize: Boolean, // 如果 container 尺寸不会发生变化，最好设置它可以优化性能
        tag: {
            type: String,
            default: "div"
        },
        // 加载锁定 tangDM++
        busyLoading: {
            type: Boolean,
            default: false
        },
        // 触顶或触左，滚动条位置偏移一小段距离
        loadDistance: {
            type: Boolean,
            default: false
        }
    },

    data() {
        return {
            sizeWidth: "0",
            sizeHeight: "0",
            moveX: 0,
            moveY: 0,
            cacheScrollHeight: null,
            cacheScrollWidth: null
        };
    },

    computed: {
        wrap() {
            return this.$refs.wrap;
        }
    },

    render(h) {
        let gutter = scrollbarWidth();
        let style = this.wrapStyle;

        if (gutter) {
            const gutterWith = `-${gutter}px`;
            const gutterStyle = `margin-bottom: ${gutterWith}; margin-right: ${gutterWith};`;

            if (Array.isArray(this.wrapStyle)) {
                style = toObject(this.wrapStyle);
                style.marginRight = style.marginBottom = gutterWith;
            } else if (typeof this.wrapStyle === "string") {
                style += gutterStyle;
            } else {
                style = gutterStyle;
            }
        }
        const view = h(
            this.tag,
            {
                class: ["el-scrollbar__view", this.viewClass],
                style: this.viewStyle,
                ref: "resize"
            },
            this.$slots.default
        );
        const wrap = (
            <div
                ref="wrap"
                style={style}
                onScroll={this.handleScroll}
                class={[this.wrapClass, "el-scrollbar__wrap", gutter ? "" : "el-scrollbar__wrap--hidden-default"]}
            >
                {[view]}
            </div>
        );
        let nodes;

        if (!this.native) {
            nodes = [
                wrap,
                <Bar move={this.moveX} size={this.sizeWidth} />,
                <Bar vertical move={this.moveY} size={this.sizeHeight} />
            ];
        } else {
            nodes = [
                <div ref="wrap" class={[this.wrapClass, "el-scrollbar__wrap"]} style={style}>
                    {[view]}
                </div>
            ];
        }
        return h("div", { class: "el-scrollbar" }, nodes);
    },

    methods: {
        handleScroll() {
            const wrap = this.wrap;

            // create-start author:tangDM #若内容没超出，则不滚动
            if (wrap.scrollHeight === wrap.clientHeight) return false;
            // create-end author:tangDM
            
            this.moveY = (wrap.scrollTop * 100) / wrap.clientHeight;
            this.moveX = (wrap.scrollLeft * 100) / wrap.clientWidth;

            // create-start author:tangDM
            // emit for listening scroll event
            this.$emit("scroll-event", wrap);

            // added for scrollbar go to content 's top side
            this.scrollToTopEvent();

            // added for scrollbar go to content 's bottom side
            this.scrollToBottomEvent();

            // added for scrollbar go to content 's left side
            this.scrollToLeftEvent();

            // added for scrollbar go to content 's right side
            this.scrollToRightEvent();
            // create-end author:tangDM
        },
        /**
         * 滚动条滚动到顶部触发事件
         *
         * create-start author:tangDM
         */
        scrollToTopEvent() {
            let wrap = this.wrap;

            // 更新缓存的滚动内容高度
            this.cacheScrollHeight = wrap.scrollHeight;

            if (wrap.scrollTop === 0 && !this.busyLoading) {
                this.$emit("scroll-top");
            }
        },
        /**
         * 滚动条滚动到底部触发事件
         *
         * create-start author:tangDM
         */
        scrollToBottomEvent() {
            const wrap = this.wrap;

            // 更新缓存的滚动内容高度
            this.cacheScrollHeight = wrap.scrollHeight;

            // 检测是否滚动到底部
            if (wrap.scrollTop && wrap.scrollTop + wrap.clientHeight === wrap.scrollHeight && !this.busyLoading) {
                this.$nextTick(() => {
                    this.$emit("scroll-bottom");
                });
            }
        },
        /**
         * 滚动条滚动到左侧触发事件
         *
         * create-start author:tangDM
         */
        scrollToLeftEvent() {
            const wrap = this.wrap;

            // 更新缓存的滚动内容宽度
            this.cacheScrollWidth = wrap.scrollWidth;

            if (wrap.scrollLeft === 0 && !this.busyLoading) {
                this.$emit("scroll-left");
            }
        },
        /**
         * 滚动条滚动到右侧触发事件
         *
         * create-start author:tangDM
         */
        scrollToRightEvent() {
            const wrap = this.wrap;

            // 更新缓存的滚动内容宽度
            this.cacheScrollWidth = wrap.scrollWidth;

            if (wrap.scrollLeft + wrap.clientWidth === wrap.scrollWidth && !this.busyLoading) {
                this.$emit("scroll-right");
            }
        },
        /**
         * 滚动条滚动置顶
         *
         * create-start author:tangDM
         */
        goScrollToTop() {
            this.goScrollToYAxis(0);
        },
        /**
         * 滚动条滚动置底
         *
         * create-start author:tangDM
         */
        goScrollToBottom() {
            this.goScrollToYAxis(this.wrap.scrollHeight);
        },
        /**
         * 滚动到 YAxis 指定的位置
         *
         * @param y 滚动到的位置值
         * @param animateTime 滚动执行的时间
         * @param callback [Function] 回调方法
         *
         * create-start author:tangDM
         */
        goScrollToYAxis(y, animateTime = 1000, callback) {
            $(this.wrap).animate(
                {
                    scrollTop: y
                },
                animateTime,
                function() {
                    callback && callback();
                }
            );

            this.moveY = (y * 100) / this.wrap.clientHeight;
        },

        /**
         * 滚动到 XAxis 指定的位置
         *
         * @param x 滚动到的位置值
         * @param animateTime 滚动执行的时间
         * @param callback [Function] 回调方法
         *
         * create-start author:tangDM
         */
        goScrollToXAxis(x, animateTime = 1000, callback) {
            $(this.wrap).animate(
                {
                    scrollLeft: x
                },
                animateTime,
                function() {
                    callback && callback();
                }
            );

            this.moveX = x / this.wrap.clientWidth;
        },
        /**
         * 重置滚动条的尺寸
         *
         * create-start author:tangDM
         */
        update() {
            let heightPercentage, widthPercentage;
            const wrap = this.wrap;
            if (!wrap) return;

            heightPercentage = (wrap.clientHeight * 100) / wrap.scrollHeight;
            widthPercentage = (wrap.clientWidth * 100) / wrap.scrollWidth;

            this.sizeHeight = heightPercentage < 100 ? heightPercentage + "%" : "";
            this.sizeWidth = widthPercentage < 100 ? widthPercentage + "%" : "";

            // create-start author:tangDM #更新滚动位置
            this.wrap.scrollTop =
                this.loadDistance && this.cacheScrollHeight && wrap.scrollTop === 0
                    ? wrap.scrollHeight - this.cacheScrollHeight
                    : wrap.scrollTop;
            this.wrap.scrollLeft =
                this.loadDistance && this.cacheScrollWidth && wrap.scrollLeft === 0
                    ? wrap.scrollWidth - this.cacheScrollWidth
                    : wrap.scrollLeft;
            // create-end
        }
    },

    mounted() {
        if (this.native) return;
        this.$nextTick(this.update);
        !this.noresize && addResizeListener(this.$refs.resize, this.update);
    },

    beforeDestroy() {
        if (this.native) return;
        !this.noresize && removeResizeListener(this.$refs.resize, this.update);
    }
};
