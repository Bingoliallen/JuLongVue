/**
 * 一个简单的函数防抖
 * @param {Function} fn 需要限制执行频率的函数
 * @param {Number} delay 延迟时间，这段时间过后，才可触发第二次
 */
export function Debounce(fn, delay) {
  let timer = null;
  function debounce() {
    const ctx = this;
    const args = arguments;
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(function () {
      fn.apply(ctx, args);
    }, delay);
  }
  return debounce;
}

// 一个简单的事件订阅发布的实现，取代原生Event对象，提升IE下的兼容性
export function LoadEvent() {
  this.listeners = {};
  this.on = function (eventName, callback) {
    if (this.listeners[eventName] === undefined) {
      this.listeners[eventName] = [];
    }
    this.listeners[eventName].push(callback)
  };
  this.emit = function (eventName) {
    this.listeners[eventName] && this.listeners[eventName].forEach(callback => callback());
  }
}
