import { AbsBufferedCodedicApi } from "./abstract/AbsBufferedCodedicApi";
import { DubboBufferedCodedicApi } from "./dubbo/DubboBufferedCodedicApi";
import { SbootBufferedCodedicApi } from "./sboot/SbootBufferedCodedicApi";
let codedicCaches = {};
let waitPools = {}; //表码请求等待池
/**
 * 代码缓存门面类
 */
class BufferedCodedicApi extends AbsBufferedCodedicApi {
    api = null; //实际的api类
    codedicCache = null; //该模块下的代码缓存，sboot下是统一，后续改造
    constructor(module) {
        super(module);
        //1.初始化api
        if (this.moduletype == "sboot") {
            this.api = new SbootBufferedCodedicApi(module);
        } else if (this.moduletype == "dubbo") {
            this.api = new DubboBufferedCodedicApi(module);
        }
        //2.初始化缓存
        let codedicCache = codedicCaches[this.module];
        if (!codedicCache) {
            codedicCache = {};
            codedicCaches[this.module] = codedicCache;
        }
        this.codedicCache = codedicCache;
    }

    /**
     * 将表码、url转换为数据
     * @param {Object} props 组件参数
     * @param {function} callback 回调函数
     * @return {Promise<any>} 请求数据的Promise对象
     */
    reqData(props, callback,type) {
        let the=this;
        if (props.code) {
            if(props.noCache){
                this.refreshCodeId(props.code, props.loadingShow ,data => {
                    let result=the.getRefreshResult(data,type);
                    callback(result);
                });
            }else{
                this.getCodeMap(props.code ,data => {
                    let result=the.getResult(data,type);
                    callback(result);
                },false,props.loadingShow);
            }
        } else {
            let reqFun = this.getReqFun(props);
            let reqKeyWord = this.getReqKeyWord(props);
            return reqFun
                .apply(this.api, [reqKeyWord])
                .then(({ data }) => {
                    callback(data);
                })
                .catch(error => {
                    console.error(error);
                });
        }
    }
    /**
     *
     * @param data
     * @param type
     * @returns 刷新数据结构过滤
     */
    getRefreshResult(data,type){
        let result=data;
        try {
            if(type!='Object'){
                result=[];
                Object.keys(data).map(item => {
                    result.push({
                        value: item,
                        label: data[item]
                    });
                });
            }
        } catch (er) {
            return;
        }
        return result;
    }
    /**
     *
     * @param data
     * @param type
     * @returns 数据结构过滤
     */
    getResult(data,type){
        let result=[];
        try {
            if(type!='Object'){
                data.forEach((item)=> {
                    let key = Object.keys(item)[0];
                    result.push({
                        value: key,
                        label: item[key]
                    });
                });
            }else{
                result = {}
                data.forEach((item)=>{
                    let key=Object.keys(item)[0]
                    result[String(key)] = item[key]
                })
            }
        } catch (er) {
            return;
        }
        return result;
    }

    /**
     * 获取请求的关键字
     * @param {Object} props 转换参数(code,enum,url,valueName,labelName)
     * @return {*} {String} 请求的关键字
     */
    getReqKeyWord(props) {
        if (props.url) return props.url;
    }

    /**
     * 获取需要调用的请求方法
     * @param {Object} props 转换参数(code,enum,url,valueName,labelName)
     * @return {*} {function} 数据请求函数
     */
    getReqFun(props) {
        if (props.url) return this.api.fetchUrl;
        return () =>
            new Promise(resolve => {
                resolve({ data: props.data });
            });
    }

    /**
     * 获取表码不使用缓存
     * @param codeId
     * @param callback
     * @param isUnCache
     */
    getCodeMap(codeId, callback, isUnCache,loadingShow) {
        let codeMap = this.codedicCache[codeId];
        if (codeMap && !isUnCache) {
            callback(codeMap);
        } else {
            // 判断等待池中是否有相同的请求
            let waitPool = waitPools[codeId];
            if (waitPool) {
                // 等待池返回后再执行操作
                waitPool.then(function(map) {
                    callback(map);
                });
            } else {
                let the = this;
                waitPool = new Promise((resolve, reject) => {
                    if (isUnCache) {
                        // 清除旧表码
                        if (the.codedicCache[codeId]) {
                            delete the.codedicCache[codeId];
                        }
                        // 不使用缓存则调用刷新指定codeid的表码接口
                        the.api.refreshCodeId(codeId,loadingShow, map => {
                            // 表码双向绑定
                            the.codedicCache[codeId] = map;
                            //请求回来的等待池
                            delete waitPools[codeId];
                            resolve(map);
                            callback(map);
                        });
                    } else {
                        // 获取表码
                        the.api.getCodeMap(codeId, loadingShow,map => {
                            the.codedicCache[codeId] = map;
                            delete waitPools[codeId];
                            resolve(map);
                            callback(map);
                        });
                    }
                });
                waitPools[codeId] = waitPool;
            }
        }
    }

    /**
     * 获取名称， 注意后面改造支持逗号分隔转换多个名称
     * @param codeId
     * @param bh
     * @param callback
     */
    getMc(codeId, bh,loadingShow, callback) {
        if (bh) {
            this.getCodeMap(codeId, function(codeMap) {
                let mc = codeMap[bh];
                callback(mc);
            },false,loadingShow);
        } else {
            callback("");
        }
    }
    /**
     * 根据逗号分隔的编号获取名称
     * @param codeId
     * @param vBhs 逗号分隔字符串
     * @param callback
     */
    getMCS(param,vBhs, callback) {
        let the=this;
        if (vBhs && vBhs != null && vBhs != "null") {
            this.reqData(param,function (codeData) {
                let data = vBhs.split(",");
                let result = [];
                data.forEach(item => {
                    if (codeData) {

                        result.push(codeData[item]);
                    }
                });
                let mc = result.join(",");
                callback(mc);

            },'Object');
        }
    }
    /**
     * 根据名称获取编号
     * @param codeid
     * @param mc 表码名称
     * @return  表码编号
     */
    getBH(codeId, mc, loadingShow,callback) {
        this.getCodeMap(codeId, function(codeMap) {
            let data = "";
            codeMap.some(function(item) {
                let key = Object.keys(item)[0];
                if(mc ==item[key]) {
                    data = key;
                    return true;
                }
            });
            callback(data);
        },false,loadingShow);
    }

    /**
     * 刷新所有表码缓存
     * @param callback
     */
    refreshAll(loading,callback) {
        //this.codedicCache={};
        for (let codeId in this.codedicCache) {
            delete this.codedicCache[codeId];
        }
        codedicCaches[this.module] = this.codedicCache;
        this.api.refreshAll(loading,callback);
    }
    /**
     * 刷新指定codeid的表码
     * @param codeId
     * @param callback
     */
    refreshCodeId(codeId, loading, callback) {
        this.getCodeMap(codeId, callback, true,loading);
    }
}
export { BufferedCodedicApi };
